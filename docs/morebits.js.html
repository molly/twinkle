<!doctype html>
<html>
        <head>
                <meta name="generator" content="JSDoc 3.6.6">
                <meta charset="utf-8">
                <title>Source: morebits.js</title>
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
                <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
                <link href="css/baseline.css" rel="stylesheet">
        </head>
        <body onload="prettyPrint()">
                <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
        <div id="jsdoc-navbar-content">
            <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
        </div>
    </div>
</nav>

                <div id="jsdoc-body-container">
                        <div id="jsdoc-content">
                                <div id="jsdoc-content-container">
                                        <div id="jsdoc-banner" role="banner">
                                        </div>
                                        <div id="jsdoc-main" role="main">
            <header class="page-header">
                <h1>Source: morebits.js</h1>
            </header>
            <article>
                <pre class="prettyprint linenums"><code>// &amp;lt;nowiki&gt;
/**
 * A library full of lots of goodness for user scripts on MediaWiki wikis, including Wikipedia.
 *
 * The highlights include:
 * - {@link Morebits.wiki.api} - make calls to the MediaWiki API
 * - {@link Morebits.wiki.page} - modify pages on the wiki (edit, revert, delete, etc.)
 * - {@link Morebits.date} - enhanced date object processing, sort of a light moment.js
 * - {@link Morebits.quickForm} - generate quick HTML forms on the fly
 * - {@link Morebits.simpleWindow} - a wrapper for jQuery UI Dialog with a custom look and extra features
 * - {@link Morebits.status} - a rough-and-ready status message displayer, used by the Morebits.wiki classes
 * - {@link Morebits.wikitext} - utilities for dealing with wikitext
 * - {@link Morebits.string} - utilities for manipulating strings
 * - {@link Morebits.array} - utilities for manipulating arrays
 *
 * Dependencies:
 * - The whole thing relies on jQuery.  But most wikis should provide this by default.
 * - {@link Morebits.quickForm}, {@link Morebits.simpleWindow}, and {@link Morebits.status} rely on the &quot;morebits.css&quot; file for their styling.
 * - {@link Morebits.simpleWindow} and {@link Morebits.quickForm} tooltips rely on jQuery UI Dialog (from ResourceLoader module name &#x27;jquery.ui&#x27;).
 * - To create a gadget based on morebits.js, use this syntax in MediaWiki:Gadgets-definition:
 *     - &#x60;*GadgetName[ResourceLoader|dependencies&#x3D;mediawiki.user,mediawiki.util,mediawiki.Title,jquery.ui]|morebits.js|morebits.css|GadgetName.js&#x60;
 * - Alternatively, you can configure morebits.js as a hidden gadget in MediaWiki:Gadgets-definition:
 *     - &#x60;*morebits[ResourceLoader|dependencies&#x3D;mediawiki.user,mediawiki.util,mediawiki.Title,jquery.ui|hidden]|morebits.js|morebits.css&#x60;
 *     and then load ext.gadget.morebits as one of the dependencies for the new gadget.
 *
 * All the stuff here works on all browsers for which MediaWiki provides JavaScript support.
 *
 * This library is maintained by the maintainers of Twinkle.
 * For queries, suggestions, help, etc., head to [Wikipedia talk:Twinkle on English Wikipedia](http://en.wikipedia.org/wiki/WT:TW).
 * The latest development source is available at {@link https://github.com/wikimedia-gadgets/twinkle/blob/master/morebits.js|GitHub}.
 *
 * @namespace Morebits
 */


(function (window, document, $) { // Wrap entire file with anonymous function

/** @lends Morebits */
var Morebits &#x3D; {};
window.Morebits &#x3D; Morebits;  // allow global access


/**
 * Simple helper function to see what groups a user might belong.
 *
 * @param {string} group - e.g. &#x60;sysop&#x60;, &#x60;extendedconfirmed&#x60;, etc.
 * @returns {boolean}
 */
Morebits.userIsInGroup &#x3D; function (group) {
	return mw.config.get(&#x27;wgUserGroups&#x27;).indexOf(group) !&#x3D;&#x3D; -1;
};
/** Hardcodes whether the user is a sysop, used a lot.
 *
 * @type {boolean}
 */
Morebits.userIsSysop &#x3D; Morebits.userIsInGroup(&#x27;sysop&#x27;);

/**
 * Converts an IPv6 address to the canonical form stored and used by MediaWiki.
 * JavaScript translation of the {@link https://gerrit.wikimedia.org/r/plugins/gitiles/mediawiki/core/+/8eb6ac3e84ea3312d391ca96c12c49e3ad0753bb/includes/utils/IP.php#131|&#x60;IP::sanitizeIP()&#x60;}
 * function from the IPUtils library.  Adddresses are verbose, uppercase,
 * normalized, and expanded to 8 words.
 *
 * @param {string} address - The IPv6 address, with or without CIDR.
 * @returns {string}
 */
Morebits.sanitizeIPv6 &#x3D; function (address) {
	address &#x3D; address.trim();
	if (address &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
		return null;
	}
	if (!mw.util.isIPv6Address(address, true)) {
		return address; // nothing else to do for IPv4 addresses or invalid ones
	}
	// Remove any whitespaces, convert to upper case
	address &#x3D; address.toUpperCase();
	// Expand zero abbreviations
	var abbrevPos &#x3D; address.indexOf(&#x27;::&#x27;);
	if (abbrevPos &gt; -1) {
		// We know this is valid IPv6. Find the last index of the
		// address before any CIDR number (e.g. &quot;a:b:c::/24&quot;).
		var CIDRStart &#x3D; address.indexOf(&#x27;/&#x27;);
		var addressEnd &#x3D; CIDRStart !&#x3D;&#x3D; -1 ? CIDRStart - 1 : address.length - 1;
		// If the &#x27;::&#x27; is at the beginning...
		var repeat, extra, pad;
		if (abbrevPos &#x3D;&#x3D;&#x3D; 0) {
			repeat &#x3D; &#x27;0:&#x27;;
			extra &#x3D; address &#x3D;&#x3D;&#x3D; &#x27;::&#x27; ? &#x27;0&#x27; : &#x27;&#x27;; // for the address &#x27;::&#x27;
			pad &#x3D; 9; // 7+2 (due to &#x27;::&#x27;)
		// If the &#x27;::&#x27; is at the end...
		} else if (abbrevPos &#x3D;&#x3D;&#x3D; (addressEnd - 1)) {
			repeat &#x3D; &#x27;:0&#x27;;
			extra &#x3D; &#x27;&#x27;;
			pad &#x3D; 9; // 7+2 (due to &#x27;::&#x27;)
		// If the &#x27;::&#x27; is in the middle...
		} else {
			repeat &#x3D; &#x27;:0&#x27;;
			extra &#x3D; &#x27;:&#x27;;
			pad &#x3D; 8; // 6+2 (due to &#x27;::&#x27;)
		}
		var replacement &#x3D; repeat;
		pad -&#x3D; address.split(&#x27;:&#x27;).length - 1;
		for (var i &#x3D; 1; i &amp;lt; pad; i++) {
			replacement +&#x3D; repeat;
		}
		replacement +&#x3D; extra;
		address &#x3D; address.replace(&#x27;::&#x27;, replacement);
	}
	// Remove leading zeros from each bloc as needed
	return address.replace(/(^|:)0+([0-9A-Fa-f]{1,4})/g, &#x27;$1$2&#x27;);
};

/**
 * Determines whether the current page is a redirect or soft redirect. Fails
 * to detect soft redirects on edit, history, etc. pages.  Will attempt to
 * detect Module:RfD, with the same failure points.
 *
 * @returns {boolean}
 */
Morebits.isPageRedirect &#x3D; function() {
	return !!(mw.config.get(&#x27;wgIsRedirect&#x27;) || document.getElementById(&#x27;softredirect&#x27;) || $(&#x27;.box-RfD&#x27;).length);
};

/**
 * Stores a normalized (underscores converted to spaces) version of the
 * &#x60;wgPageName&#x60; variable.
 *
 * @type {string}
 */
Morebits.pageNameNorm &#x3D; mw.config.get(&#x27;wgPageName&#x27;).replace(/_/g, &#x27; &#x27;);


/**
 * Create a string for use in regex matching a page name.  Accounts for
 * leading character&#x27;s capitalization, underscores as spaces, and special
 * characters being escaped.  See also {@link Morebits.namespaceRegex}.
 *
 * @param {string} pageName - Page name without namespace.
 * @returns {string} - For a page name &#x60;Foo bar&#x60;, returns the string &#x60;[Ff]oo[_ ]bar&#x60;.
 */
Morebits.pageNameRegex &#x3D; function(pageName) {
	if (pageName &#x3D;&#x3D;&#x3D; &#x27;&#x27;) {
		return &#x27;&#x27;;
	}
	var firstChar &#x3D; pageName[0],
		remainder &#x3D; Morebits.string.escapeRegExp(pageName.slice(1));
	if (mw.Title.phpCharToUpper(firstChar) !&#x3D;&#x3D; firstChar.toLowerCase()) {
		return &#x27;[&#x27; + mw.Title.phpCharToUpper(firstChar) + firstChar.toLowerCase() + &#x27;]&#x27; + remainder;
	}
	return Morebits.string.escapeRegExp(firstChar) + remainder;
};

/**
 * Create a string for use in regex matching all namespace aliases, regardless
 * of the capitalization and underscores/spaces.  Doesn&#x27;t include the optional
 * leading &#x60;:&#x60;, but if there&#x27;s more than one item, wraps the list in a
 * non-capturing group.  This means you can do &#x60;Morebits.namespaceRegex([4]) +
 * &#x27;:&#x27; + Morebits.pageNameRegex(&#x27;Twinkle&#x27;)&#x60; to match a full page.  Uses
 * {@link Morebits.pageNameRegex}.
 *
 * @param {number[]} namespaces - Array of namespace numbers.  Unused/invalid
 * namespace numbers are silently discarded.
 * @example
 * // returns &#x27;(?:[Ff][Ii][Ll][Ee]|[Ii][Mm][Aa][Gg][Ee])&#x27;
 * Morebits.namespaceRegex([6])
 * @returns {string} - Regex-suitable string of all namespace aliases.
 */
Morebits.namespaceRegex &#x3D; function(namespaces) {
	if (!Array.isArray(namespaces)) {
		namespaces &#x3D; [namespaces];
	}
	var aliases &#x3D; [], regex;
	$.each(mw.config.get(&#x27;wgNamespaceIds&#x27;), function(name, number) {
		if (namespaces.indexOf(number) !&#x3D;&#x3D; -1) {
			// Namespaces are completely agnostic as to case,
			// and a regex string is more useful/compatibile than a RegExp object,
			// so we accept any casing for any letter.
			aliases.push(name.split(&#x27;&#x27;).map(function(char) {
				return Morebits.pageNameRegex(char);
			}).join(&#x27;&#x27;));
		}
	});
	switch (aliases.length) {
		case 0:
			regex &#x3D; &#x27;&#x27;;
			break;
		case 1:
			regex &#x3D; aliases[0];
			break;
		default:
			regex &#x3D; &#x27;(?:&#x27; + aliases.join(&#x27;|&#x27;) + &#x27;)&#x27;;
			break;
	}
	return regex;
};


/* **************** Morebits.quickForm **************** */
/**
 * Creation of simple and standard forms without much specific coding.
 *
 * @namespace Morebits.quickForm
 * @memberof Morebits
 * @class
 * @param {event} event - Function to execute when form is submitted.
 * @param {string} [eventType&#x3D;submit] - Type of the event.
 */
Morebits.quickForm &#x3D; function QuickForm(event, eventType) {
	this.root &#x3D; new Morebits.quickForm.element({ type: &#x27;form&#x27;, event: event, eventType: eventType });
};

/**
 * Renders the HTML output of the quickForm.
 *
 * @memberof Morebits.quickForm
 * @returns {HTMLElement}
 */
Morebits.quickForm.prototype.render &#x3D; function QuickFormRender() {
	var ret &#x3D; this.root.render();
	ret.names &#x3D; {};
	return ret;
};

/**
 * Append element to the form.
 *
 * @memberof Morebits.quickForm
 * @param {(object|Morebits.quickForm.element)} data - A quickform element, or the object with which
 * a quickform element is constructed.
 * @returns {Morebits.quickForm.element} - Same as what is passed to the function.
 */
Morebits.quickForm.prototype.append &#x3D; function QuickFormAppend(data) {
	return this.root.append(data);
};

/**
 * Create a new element for the the form.
 *
 * Index to Morebits.quickForm.element types:
 * - Global attributes: id, className, style, tooltip, extra, adminonly
 * - &#x60;select&#x60;: A combo box (aka drop-down).
 *     - Attributes: name, label, multiple, size, list, event, disabled
 *  - &#x60;option&#x60;: An element for a combo box.
 *      - Attributes: value, label, selected, disabled
 *  - &#x60;optgroup&#x60;: A group of &quot;option&quot;s.
 *      - Attributes: label, list
 *  - &#x60;field&#x60;: A fieldset (aka group box).
 *      - Attributes: name, label, disabled
 *  - &#x60;checkbox&#x60;: A checkbox. Must use &quot;list&quot; parameter.
 *      - Attributes: name, list, event
 *      - Attributes (within list): name, label, value, checked, disabled, event, subgroup
 *  - &#x60;radio&#x60;: A radio button. Must use &quot;list&quot; parameter.
 *      - Attributes: name, list, event
 *      - Attributes (within list): name, label, value, checked, disabled, event, subgroup
 *  - &#x60;input&#x60;: A text box.
 *      - Attributes: name, label, value, size, disabled, required, readonly, maxlength, event
 *  - &#x60;dyninput&#x60;: A set of text boxes with &quot;Remove&quot; buttons and an &quot;Add&quot; button.
 *      - Attributes: name, label, min, max, sublabel, value, size, maxlength, event
 *  - &#x60;hidden&#x60;: An invisible form field.
 *      - Attributes: name, value
 *  - &#x60;header&#x60;: A level 5 header.
 *      - Attributes: label
 *  - &#x60;div&#x60;: A generic placeholder element or label.
 *      - Attributes: name, label
 *  - &#x60;submit&#x60;: A submit button. Morebits.simpleWindow moves these to the footer of the dialog.
 *      - Attributes: name, label, disabled
 *  - &#x60;button&#x60;: A generic button.
 *      - Attributes: name, label, disabled, event
 *  - &#x60;textarea&#x60;: A big, multi-line text box.
 *      - Attributes: name, label, value, cols, rows, disabled, required, readonly
 *  - &#x60;fragment&#x60;: A DocumentFragment object.
 *      - No attributes, and no global attributes except adminonly.
 *
 * @memberof Morebits.quickForm
 * @class
 * @param {object} data - Object representing the quickform element. Should
 * specify one of the available types from the index above, as well as any
 * relevant and available attributes.
 * @example new Morebits.quickForm.element({
 *     name: &#x27;target&#x27;,
 *     type: &#x27;input&#x27;,
 *     label: &#x27;Your target:&#x27;,
 *     tooltip: &#x27;Enter your target. Required.&#x27;,
 *     required: true
 * });
 */
Morebits.quickForm.element &#x3D; function QuickFormElement(data) {
	this.data &#x3D; data;
	this.childs &#x3D; [];
	this.id &#x3D; Morebits.quickForm.element.id++;
};

/**
 * @memberof Morebits.quickForm.element
 * @type {number}
 */
Morebits.quickForm.element.id &#x3D; 0;

/**
 * Appends an element to current element.
 *
 * @memberof Morebits.quickForm.element
 * @param {Morebits.quickForm.element} data - A quickForm element or the object required to
 * create the quickForm element.
 * @returns {Morebits.quickForm.element} The same element passed in.
 */
Morebits.quickForm.element.prototype.append &#x3D; function QuickFormElementAppend(data) {
	var child;
	if (data instanceof Morebits.quickForm.element) {
		child &#x3D; data;
	} else {
		child &#x3D; new Morebits.quickForm.element(data);
	}
	this.childs.push(child);
	return child;
};

/**
 * Renders the HTML output for the quickForm element.  This should be called
 * without parameters: &#x60;form.render()&#x60;.
 *
 * @memberof Morebits.quickForm.element
 * @returns {HTMLElement}
 */
Morebits.quickForm.element.prototype.render &#x3D; function QuickFormElementRender(internal_subgroup_id) {
	var currentNode &#x3D; this.compute(this.data, internal_subgroup_id);

	for (var i &#x3D; 0; i &amp;lt; this.childs.length; ++i) {
		// do not pass internal_subgroup_id to recursive calls
		currentNode[1].appendChild(this.childs[i].render());
	}
	return currentNode[0];
};

/** @memberof Morebits.quickForm.element */
Morebits.quickForm.element.prototype.compute &#x3D; function QuickFormElementCompute(data, in_id) {
	var node;
	var childContainder &#x3D; null;
	var label;
	var id &#x3D; (in_id ? in_id + &#x27;_&#x27; : &#x27;&#x27;) + &#x27;node_&#x27; + this.id;
	if (data.adminonly &amp;amp;&amp;amp; !Morebits.userIsSysop) {
		// hell hack alpha
		data.type &#x3D; &#x27;hidden&#x27;;
	}

	var i, current, subnode;
	switch (data.type) {
		case &#x27;form&#x27;:
			node &#x3D; document.createElement(&#x27;form&#x27;);
			node.className &#x3D; &#x27;quickform&#x27;;
			node.setAttribute(&#x27;action&#x27;, &#x27;javascript:void(0);&#x27;);
			if (data.event) {
				node.addEventListener(data.eventType || &#x27;submit&#x27;, data.event, false);
			}
			break;
		case &#x27;fragment&#x27;:
			node &#x3D; document.createDocumentFragment();
			// fragments can&#x27;t have any attributes, so just return it straight away
			return [ node, node ];
		case &#x27;select&#x27;:
			node &#x3D; document.createElement(&#x27;div&#x27;);

			node.setAttribute(&#x27;id&#x27;, &#x27;div_&#x27; + id);
			if (data.label) {
				label &#x3D; node.appendChild(document.createElement(&#x27;label&#x27;));
				label.setAttribute(&#x27;for&#x27;, id);
				label.appendChild(document.createTextNode(data.label));
			}
			var select &#x3D; node.appendChild(document.createElement(&#x27;select&#x27;));
			if (data.event) {
				select.addEventListener(&#x27;change&#x27;, data.event, false);
			}
			if (data.multiple) {
				select.setAttribute(&#x27;multiple&#x27;, &#x27;multiple&#x27;);
			}
			if (data.size) {
				select.setAttribute(&#x27;size&#x27;, data.size);
			}
			if (data.disabled) {
				select.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			select.setAttribute(&#x27;name&#x27;, data.name);

			if (data.list) {
				for (i &#x3D; 0; i &amp;lt; data.list.length; ++i) {

					current &#x3D; data.list[i];

					if (current.list) {
						current.type &#x3D; &#x27;optgroup&#x27;;
					} else {
						current.type &#x3D; &#x27;option&#x27;;
					}

					subnode &#x3D; this.compute(current);
					select.appendChild(subnode[0]);
				}
			}
			childContainder &#x3D; select;
			break;
		case &#x27;option&#x27;:
			node &#x3D; document.createElement(&#x27;option&#x27;);
			node.values &#x3D; data.value;
			node.setAttribute(&#x27;value&#x27;, data.value);
			if (data.selected) {
				node.setAttribute(&#x27;selected&#x27;, &#x27;selected&#x27;);
			}
			if (data.disabled) {
				node.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			node.setAttribute(&#x27;label&#x27;, data.label);
			node.appendChild(document.createTextNode(data.label));
			break;
		case &#x27;optgroup&#x27;:
			node &#x3D; document.createElement(&#x27;optgroup&#x27;);
			node.setAttribute(&#x27;label&#x27;, data.label);

			if (data.list) {
				for (i &#x3D; 0; i &amp;lt; data.list.length; ++i) {

					current &#x3D; data.list[i];
					current.type &#x3D; &#x27;option&#x27;; // must be options here

					subnode &#x3D; this.compute(current);
					node.appendChild(subnode[0]);
				}
			}
			break;
		case &#x27;field&#x27;:
			node &#x3D; document.createElement(&#x27;fieldset&#x27;);
			label &#x3D; node.appendChild(document.createElement(&#x27;legend&#x27;));
			label.appendChild(document.createTextNode(data.label));
			if (data.name) {
				node.setAttribute(&#x27;name&#x27;, data.name);
			}
			if (data.disabled) {
				node.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			break;
		case &#x27;checkbox&#x27;:
		case &#x27;radio&#x27;:
			node &#x3D; document.createElement(&#x27;div&#x27;);
			if (data.list) {
				for (i &#x3D; 0; i &amp;lt; data.list.length; ++i) {
					var cur_id &#x3D; id + &#x27;_&#x27; + i;
					current &#x3D; data.list[i];
					var cur_div;
					if (current.type &#x3D;&#x3D;&#x3D; &#x27;header&#x27;) {
					// inline hack
						cur_div &#x3D; node.appendChild(document.createElement(&#x27;h6&#x27;));
						cur_div.appendChild(document.createTextNode(current.label));
						if (current.tooltip) {
							Morebits.quickForm.element.generateTooltip(cur_div, current);
						}
						continue;
					}
					cur_div &#x3D; node.appendChild(document.createElement(&#x27;div&#x27;));
					subnode &#x3D; cur_div.appendChild(document.createElement(&#x27;input&#x27;));
					subnode.values &#x3D; current.value;
					subnode.setAttribute(&#x27;value&#x27;, current.value);
					subnode.setAttribute(&#x27;type&#x27;, data.type);
					subnode.setAttribute(&#x27;id&#x27;, cur_id);
					subnode.setAttribute(&#x27;name&#x27;, current.name || data.name);

					// If name is provided on the individual checkbox, add a data-single
					// attribute which indicates it isn&#x27;t part of a list of checkboxes with
					// same name. Used in getInputData()
					if (current.name) {
						subnode.setAttribute(&#x27;data-single&#x27;, &#x27;data-single&#x27;);
					}

					if (current.checked) {
						subnode.setAttribute(&#x27;checked&#x27;, &#x27;checked&#x27;);
					}
					if (current.disabled) {
						subnode.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
					}
					label &#x3D; cur_div.appendChild(document.createElement(&#x27;label&#x27;));
					label.appendChild(document.createTextNode(current.label));
					label.setAttribute(&#x27;for&#x27;, cur_id);
					if (current.tooltip) {
						Morebits.quickForm.element.generateTooltip(label, current);
					}
					// styles go on the label, doesn&#x27;t make sense to style a checkbox/radio
					if (current.style) {
						label.setAttribute(&#x27;style&#x27;, current.style);
					}

					var event;
					if (current.subgroup) {
						var tmpgroup &#x3D; current.subgroup;

						if (!Array.isArray(tmpgroup)) {
							tmpgroup &#x3D; [ tmpgroup ];
						}

						var subgroupRaw &#x3D; new Morebits.quickForm.element({
							type: &#x27;div&#x27;,
							id: id + &#x27;_&#x27; + i + &#x27;_subgroup&#x27;
						});
						$.each(tmpgroup, function(idx, el) {
							var newEl &#x3D; $.extend({}, el);
							if (!newEl.type) {
								newEl.type &#x3D; data.type;
							}
							newEl.name &#x3D; (current.name || data.name) + &#x27;.&#x27; + newEl.name;
							subgroupRaw.append(newEl);
						});

						var subgroup &#x3D; subgroupRaw.render(cur_id);
						subgroup.className &#x3D; &#x27;quickformSubgroup&#x27;;
						subnode.subgroup &#x3D; subgroup;
						subnode.shown &#x3D; false;

						event &#x3D; function(e) {
							if (e.target.checked) {
								e.target.parentNode.appendChild(e.target.subgroup);
								if (e.target.type &#x3D;&#x3D;&#x3D; &#x27;radio&#x27;) {
									var name &#x3D; e.target.name;
									if (e.target.form.names[name] !&#x3D;&#x3D; undefined) {
										e.target.form.names[name].parentNode.removeChild(e.target.form.names[name].subgroup);
									}
									e.target.form.names[name] &#x3D; e.target;
								}
							} else {
								e.target.parentNode.removeChild(e.target.subgroup);
							}
						};
						subnode.addEventListener(&#x27;change&#x27;, event, true);
						if (current.checked) {
							subnode.parentNode.appendChild(subgroup);
						}
					} else if (data.type &#x3D;&#x3D;&#x3D; &#x27;radio&#x27;) {
						event &#x3D; function(e) {
							if (e.target.checked) {
								var name &#x3D; e.target.name;
								if (e.target.form.names[name] !&#x3D;&#x3D; undefined) {
									e.target.form.names[name].parentNode.removeChild(e.target.form.names[name].subgroup);
								}
								delete e.target.form.names[name];
							}
						};
						subnode.addEventListener(&#x27;change&#x27;, event, true);
					}
					// add users&#x27; event last, so it can interact with the subgroup
					if (data.event) {
						subnode.addEventListener(&#x27;change&#x27;, data.event, false);
					} else if (current.event) {
						subnode.addEventListener(&#x27;change&#x27;, current.event, true);
					}
				}
			}
			if (data.shiftClickSupport &amp;amp;&amp;amp; data.type &#x3D;&#x3D;&#x3D; &#x27;checkbox&#x27;) {
				Morebits.checkboxShiftClickSupport(Morebits.quickForm.getElements(node, data.name));
			}
			break;
		case &#x27;input&#x27;:
			node &#x3D; document.createElement(&#x27;div&#x27;);
			node.setAttribute(&#x27;id&#x27;, &#x27;div_&#x27; + id);

			if (data.label) {
				label &#x3D; node.appendChild(document.createElement(&#x27;label&#x27;));
				label.appendChild(document.createTextNode(data.label));
				label.setAttribute(&#x27;for&#x27;, data.id || id);
			}

			subnode &#x3D; node.appendChild(document.createElement(&#x27;input&#x27;));
			if (data.value) {
				subnode.setAttribute(&#x27;value&#x27;, data.value);
			}
			subnode.setAttribute(&#x27;name&#x27;, data.name);
			subnode.setAttribute(&#x27;type&#x27;, &#x27;text&#x27;);
			if (data.size) {
				subnode.setAttribute(&#x27;size&#x27;, data.size);
			}
			if (data.disabled) {
				subnode.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			if (data.required) {
				subnode.setAttribute(&#x27;required&#x27;, &#x27;required&#x27;);
			}
			if (data.readonly) {
				subnode.setAttribute(&#x27;readonly&#x27;, &#x27;readonly&#x27;);
			}
			if (data.maxlength) {
				subnode.setAttribute(&#x27;maxlength&#x27;, data.maxlength);
			}
			if (data.event) {
				subnode.addEventListener(&#x27;keyup&#x27;, data.event, false);
			}
			childContainder &#x3D; subnode;
			break;
		case &#x27;dyninput&#x27;:
			var min &#x3D; data.min || 1;
			var max &#x3D; data.max || Infinity;

			node &#x3D; document.createElement(&#x27;div&#x27;);

			label &#x3D; node.appendChild(document.createElement(&#x27;h5&#x27;));
			label.appendChild(document.createTextNode(data.label));

			var listNode &#x3D; node.appendChild(document.createElement(&#x27;div&#x27;));

			var more &#x3D; this.compute({
				type: &#x27;button&#x27;,
				label: &#x27;more&#x27;,
				disabled: min &gt;&#x3D; max,
				event: function(e) {
					var new_node &#x3D; new Morebits.quickForm.element(e.target.sublist);
					e.target.area.appendChild(new_node.render());

					if (++e.target.counter &gt;&#x3D; e.target.max) {
						e.target.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
					}
					e.stopPropagation();
				}
			});

			node.appendChild(more[0]);
			var moreButton &#x3D; more[1];

			var sublist &#x3D; {
				type: &#x27;_dyninput_element&#x27;,
				label: data.sublabel || data.label,
				name: data.name,
				value: data.value,
				size: data.size,
				remove: false,
				maxlength: data.maxlength,
				event: data.event
			};

			for (i &#x3D; 0; i &amp;lt; min; ++i) {
				var elem &#x3D; new Morebits.quickForm.element(sublist);
				listNode.appendChild(elem.render());
			}
			sublist.remove &#x3D; true;
			sublist.morebutton &#x3D; moreButton;
			sublist.listnode &#x3D; listNode;

			moreButton.sublist &#x3D; sublist;
			moreButton.area &#x3D; listNode;
			moreButton.max &#x3D; max - min;
			moreButton.counter &#x3D; 0;
			break;
		case &#x27;_dyninput_element&#x27;: // Private, similar to normal input
			node &#x3D; document.createElement(&#x27;div&#x27;);

			if (data.label) {
				label &#x3D; node.appendChild(document.createElement(&#x27;label&#x27;));
				label.appendChild(document.createTextNode(data.label));
				label.setAttribute(&#x27;for&#x27;, id);
			}

			subnode &#x3D; node.appendChild(document.createElement(&#x27;input&#x27;));
			if (data.value) {
				subnode.setAttribute(&#x27;value&#x27;, data.value);
			}
			subnode.setAttribute(&#x27;name&#x27;, data.name);
			subnode.setAttribute(&#x27;type&#x27;, &#x27;text&#x27;);
			if (data.size) {
				subnode.setAttribute(&#x27;size&#x27;, data.size);
			}
			if (data.maxlength) {
				subnode.setAttribute(&#x27;maxlength&#x27;, data.maxlength);
			}
			if (data.event) {
				subnode.addEventListener(&#x27;keyup&#x27;, data.event, false);
			}
			if (data.remove) {
				var remove &#x3D; this.compute({
					type: &#x27;button&#x27;,
					label: &#x27;remove&#x27;,
					event: function(e) {
						var list &#x3D; e.target.listnode;
						var node &#x3D; e.target.inputnode;
						var more &#x3D; e.target.morebutton;

						list.removeChild(node);
						--more.counter;
						more.removeAttribute(&#x27;disabled&#x27;);
						e.stopPropagation();
					}
				});
				node.appendChild(remove[0]);
				var removeButton &#x3D; remove[1];
				removeButton.inputnode &#x3D; node;
				removeButton.listnode &#x3D; data.listnode;
				removeButton.morebutton &#x3D; data.morebutton;
			}
			break;
		case &#x27;hidden&#x27;:
			node &#x3D; document.createElement(&#x27;input&#x27;);
			node.setAttribute(&#x27;type&#x27;, &#x27;hidden&#x27;);
			node.values &#x3D; data.value;
			node.setAttribute(&#x27;value&#x27;, data.value);
			node.setAttribute(&#x27;name&#x27;, data.name);
			break;
		case &#x27;header&#x27;:
			node &#x3D; document.createElement(&#x27;h5&#x27;);
			node.appendChild(document.createTextNode(data.label));
			break;
		case &#x27;div&#x27;:
			node &#x3D; document.createElement(&#x27;div&#x27;);
			if (data.name) {
				node.setAttribute(&#x27;name&#x27;, data.name);
			}
			if (data.label) {
				if (!Array.isArray(data.label)) {
					data.label &#x3D; [ data.label ];
				}
				var result &#x3D; document.createElement(&#x27;span&#x27;);
				result.className &#x3D; &#x27;quickformDescription&#x27;;
				for (i &#x3D; 0; i &amp;lt; data.label.length; ++i) {
					if (typeof data.label[i] &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
						result.appendChild(document.createTextNode(data.label[i]));
					} else if (data.label[i] instanceof Element) {
						result.appendChild(data.label[i]);
					}
				}
				node.appendChild(result);
			}
			break;
		case &#x27;submit&#x27;:
			node &#x3D; document.createElement(&#x27;span&#x27;);
			childContainder &#x3D; node.appendChild(document.createElement(&#x27;input&#x27;));
			childContainder.setAttribute(&#x27;type&#x27;, &#x27;submit&#x27;);
			if (data.label) {
				childContainder.setAttribute(&#x27;value&#x27;, data.label);
			}
			childContainder.setAttribute(&#x27;name&#x27;, data.name || &#x27;submit&#x27;);
			if (data.disabled) {
				childContainder.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			break;
		case &#x27;button&#x27;:
			node &#x3D; document.createElement(&#x27;span&#x27;);
			childContainder &#x3D; node.appendChild(document.createElement(&#x27;input&#x27;));
			childContainder.setAttribute(&#x27;type&#x27;, &#x27;button&#x27;);
			if (data.label) {
				childContainder.setAttribute(&#x27;value&#x27;, data.label);
			}
			childContainder.setAttribute(&#x27;name&#x27;, data.name);
			if (data.disabled) {
				childContainder.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			if (data.event) {
				childContainder.addEventListener(&#x27;click&#x27;, data.event, false);
			}
			break;
		case &#x27;textarea&#x27;:
			node &#x3D; document.createElement(&#x27;div&#x27;);
			node.setAttribute(&#x27;id&#x27;, &#x27;div_&#x27; + id);
			if (data.label) {
				label &#x3D; node.appendChild(document.createElement(&#x27;h5&#x27;));
				var labelElement &#x3D; document.createElement(&#x27;label&#x27;);
				labelElement.textContent &#x3D; data.label;
				labelElement.setAttribute(&#x27;for&#x27;, data.id || id);
				label.appendChild(labelElement);
			}
			subnode &#x3D; node.appendChild(document.createElement(&#x27;textarea&#x27;));
			subnode.setAttribute(&#x27;name&#x27;, data.name);
			if (data.cols) {
				subnode.setAttribute(&#x27;cols&#x27;, data.cols);
			}
			if (data.rows) {
				subnode.setAttribute(&#x27;rows&#x27;, data.rows);
			}
			if (data.disabled) {
				subnode.setAttribute(&#x27;disabled&#x27;, &#x27;disabled&#x27;);
			}
			if (data.required) {
				subnode.setAttribute(&#x27;required&#x27;, &#x27;required&#x27;);
			}
			if (data.readonly) {
				subnode.setAttribute(&#x27;readonly&#x27;, &#x27;readonly&#x27;);
			}
			if (data.value) {
				subnode.value &#x3D; data.value;
			}
			childContainder &#x3D; subnode;
			break;
		default:
			throw new Error(&#x27;Morebits.quickForm: unknown element type &#x27; + data.type.toString());
	}

	if (!childContainder) {
		childContainder &#x3D; node;
	}
	if (data.tooltip) {
		Morebits.quickForm.element.generateTooltip(label || node, data);
	}

	if (data.extra) {
		childContainder.extra &#x3D; data.extra;
	}
	if (data.style) {
		childContainder.setAttribute(&#x27;style&#x27;, data.style);
	}
	if (data.className) {
		childContainder.className &#x3D; childContainder.className ?
			childContainder.className + &#x27; &#x27; + data.className :
			data.className;
	}
	childContainder.setAttribute(&#x27;id&#x27;, data.id || id);

	return [ node, childContainder ];
};

/**
 * Create a jQuery UI-based tooltip.
 *
 * @memberof Morebits.quickForm.element
 * @requires jquery.ui
 * @param {HTMLElement} node - The HTML element beside which a tooltip is to be generated.
 * @param {object} data - Tooltip-related configuration data.
 */
Morebits.quickForm.element.generateTooltip &#x3D; function QuickFormElementGenerateTooltip(node, data) {
	var tooltipButton &#x3D; node.appendChild(document.createElement(&#x27;span&#x27;));
	tooltipButton.className &#x3D; &#x27;morebits-tooltipButton&#x27;;
	tooltipButton.title &#x3D; data.tooltip; // Provides the content for jQuery UI
	tooltipButton.appendChild(document.createTextNode(&#x27;?&#x27;));
	$(tooltipButton).tooltip({
		position: { my: &#x27;left top&#x27;, at: &#x27;center bottom&#x27;, collision: &#x27;flipfit&#x27; },
		// Deprecated in UI 1.12, but MW stuck on 1.9.2 indefinitely; see #398 and T71386
		tooltipClass: &#x27;morebits-ui-tooltip&#x27;
	});
};


// Some utility methods for manipulating quickForms after their creation:
// (None of these work for &quot;dyninput&quot; type fields at present)

/**
 * Returns an object containing all filled form data entered by the user, with the object
 * keys being the form element names. Disabled fields will be ignored, but not hidden fields.
 *
 * @memberof Morebits.quickForm
 * @param {HTMLFormElement} form
 * @returns {object} With field names as keys, input data as values.
 */
Morebits.quickForm.getInputData &#x3D; function(form) {
	var result &#x3D; {};

	for (var i &#x3D; 0; i &amp;lt; form.elements.length; i++) {
		var field &#x3D; form.elements[i];
		if (field.disabled || !field.name || !field.type ||
			field.type &#x3D;&#x3D;&#x3D; &#x27;submit&#x27; || field.type &#x3D;&#x3D;&#x3D; &#x27;button&#x27;) {
			continue;
		}

		// For elements in subgroups, quickform prepends element names with
		// name of the parent group followed by a period, get rid of that.
		var fieldNameNorm &#x3D; field.name.slice(field.name.indexOf(&#x27;.&#x27;) + 1);

		switch (field.type) {
			case &#x27;radio&#x27;:
				if (field.checked) {
					result[fieldNameNorm] &#x3D; field.value;
				}
				break;
			case &#x27;checkbox&#x27;:
				if (field.dataset.single) {
					result[fieldNameNorm] &#x3D; field.checked; // boolean
				} else {
					result[fieldNameNorm] &#x3D; result[fieldNameNorm] || [];
					if (field.checked) {
						result[fieldNameNorm].push(field.value);
					}
				}
				break;
			case &#x27;select-multiple&#x27;:
				result[fieldNameNorm] &#x3D; $(field).val(); // field.value doesn&#x27;t work
				break;
			case &#x27;text&#x27;: // falls through
			case &#x27;textarea&#x27;:
				result[fieldNameNorm] &#x3D; field.value.trim();
				break;
			default: // could be select-one, date, number, email, etc
				if (field.value) {
					result[fieldNameNorm] &#x3D; field.value;
				}
				break;
		}
	}
	return result;
};


/**
 * Returns all form elements with a given field name or ID.
 *
 * @memberof Morebits.quickForm
 * @param {HTMLFormElement} form
 * @param {string} fieldName - The name or id of the fields.
 * @returns {HTMLElement[]} - Array of matching form elements.
 */
Morebits.quickForm.getElements &#x3D; function QuickFormGetElements(form, fieldName) {
	var $form &#x3D; $(form);
	fieldName &#x3D; $.escapeSelector(fieldName); // sanitize input
	var $elements &#x3D; $form.find(&#x27;[name&#x3D;&quot;&#x27; + fieldName + &#x27;&quot;]&#x27;);
	if ($elements.length &gt; 0) {
		return $elements.toArray();
	}
	$elements &#x3D; $form.find(&#x27;#&#x27; + fieldName);
	return $elements.toArray();
};

/**
 * Searches the array of elements for a checkbox or radio button with a certain
 * &#x60;value&#x60; attribute, and returns the first such element. Returns null if not found.
 *
 * @memberof Morebits.quickForm
 * @param {HTMLInputElement[]} elementArray - Array of checkbox or radio elements.
 * @param {string} value - Value to search for.
 * @returns {HTMLInputElement}
 */
Morebits.quickForm.getCheckboxOrRadio &#x3D; function QuickFormGetCheckboxOrRadio(elementArray, value) {
	var found &#x3D; $.grep(elementArray, function(el) {
		return el.value &#x3D;&#x3D;&#x3D; value;
	});
	if (found.length &gt; 0) {
		return found[0];
	}
	return null;
};

/**
 * Returns the &amp;amp;lt;div&gt; containing the form element, or the form element itself
 * May not work as expected on checkboxes or radios.
 *
 * @memberof Morebits.quickForm
 * @param {HTMLElement} element
 * @returns {HTMLElement}
 */
Morebits.quickForm.getElementContainer &#x3D; function QuickFormGetElementContainer(element) {
	// for divs, headings and fieldsets, the container is the element itself
	if (element instanceof HTMLFieldSetElement || element instanceof HTMLDivElement ||
			element instanceof HTMLHeadingElement) {
		return element;
	}

	// for others, just return the parent node
	return element.parentNode;
};

/**
 * Gets the HTML element that contains the label of the given form element
 * (mainly for internal use).
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|Morebits.quickForm.element)} element
 * @returns {HTMLElement}
 */
Morebits.quickForm.getElementLabelObject &#x3D; function QuickFormGetElementLabelObject(element) {
	// for buttons, divs and headers, the label is on the element itself
	if (element.type &#x3D;&#x3D;&#x3D; &#x27;button&#x27; || element.type &#x3D;&#x3D;&#x3D; &#x27;submit&#x27; ||
			element instanceof HTMLDivElement || element instanceof HTMLHeadingElement) {
		return element;
	// for fieldsets, the label is the child &amp;lt;legend&gt; element
	} else if (element instanceof HTMLFieldSetElement) {
		return element.getElementsByTagName(&#x27;legend&#x27;)[0];
	// for textareas, the label is the sibling &amp;lt;h5&gt; element
	} else if (element instanceof HTMLTextAreaElement) {
		return element.parentNode.getElementsByTagName(&#x27;h5&#x27;)[0];
	}
	// for others, the label is the sibling &amp;lt;label&gt; element
	return element.parentNode.getElementsByTagName(&#x27;label&#x27;)[0];
};

/**
 * Gets the label text of the element.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|Morebits.quickForm.element)} element
 * @returns {string}
 */
Morebits.quickForm.getElementLabel &#x3D; function QuickFormGetElementLabel(element) {
	var labelElement &#x3D; Morebits.quickForm.getElementLabelObject(element);

	if (!labelElement) {
		return null;
	}
	return labelElement.firstChild.textContent;
};

/**
 * Sets the label of the element to the given text.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|Morebits.quickForm.element)} element
 * @param {string} labelText
 * @returns {boolean} True if succeeded, false if the label element is unavailable.
 */
Morebits.quickForm.setElementLabel &#x3D; function QuickFormSetElementLabel(element, labelText) {
	var labelElement &#x3D; Morebits.quickForm.getElementLabelObject(element);

	if (!labelElement) {
		return false;
	}
	labelElement.firstChild.textContent &#x3D; labelText;
	return true;
};

/**
 * Stores the element&#x27;s current label, and temporarily sets the label to the given text.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|Morebits.quickForm.element)} element
 * @param {string} temporaryLabelText
 * @returns {boolean} &#x60;true&#x60; if succeeded, &#x60;false&#x60; if the label element is unavailable.
 */
Morebits.quickForm.overrideElementLabel &#x3D; function QuickFormOverrideElementLabel(element, temporaryLabelText) {
	if (!element.hasAttribute(&#x27;data-oldlabel&#x27;)) {
		element.setAttribute(&#x27;data-oldlabel&#x27;, Morebits.quickForm.getElementLabel(element));
	}
	return Morebits.quickForm.setElementLabel(element, temporaryLabelText);
};

/**
 * Restores the label stored by overrideElementLabel.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|Morebits.quickForm.element)} element
 * @returns {boolean} True if succeeded, false if the label element is unavailable.
 */
Morebits.quickForm.resetElementLabel &#x3D; function QuickFormResetElementLabel(element) {
	if (element.hasAttribute(&#x27;data-oldlabel&#x27;)) {
		return Morebits.quickForm.setElementLabel(element, element.getAttribute(&#x27;data-oldlabel&#x27;));
	}
	return null;
};

/**
 * Shows or hides a form element plus its label and tooltip.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|jQuery|string)} element - HTML/jQuery element, or jQuery selector string.
 * @param {boolean} [visibility] - Skip this to toggle visibility.
 */
Morebits.quickForm.setElementVisibility &#x3D; function QuickFormSetElementVisibility(element, visibility) {
	$(element).toggle(visibility);
};

/**
 * Shows or hides the question mark icon (which displays the tooltip) next to a form element.
 *
 * @memberof Morebits.quickForm
 * @param {(HTMLElement|jQuery)} element
 * @param {boolean} [visibility] - Skip this to toggle visibility.
 */
Morebits.quickForm.setElementTooltipVisibility &#x3D; function QuickFormSetElementTooltipVisibility(element, visibility) {
	$(Morebits.quickForm.getElementContainer(element)).find(&#x27;.morebits-tooltipButton&#x27;).toggle(visibility);
};



/**
 * @external HTMLFormElement
 */
/**
 * Get checked items in the form.
 *
 * @function external:HTMLFormElement.getChecked
 * @param {string} name - Find checked property of elements (i.e. a checkbox
 * or a radiobutton) with the given name, or select options that have selected
 * set to true (don&#x27;t try to mix selects with radio/checkboxes).
 * @param {string} [type] - Optionally specify either radio or checkbox (for
 * the event that both checkboxes and radiobuttons have the same name).
 * @returns {string[]} - Contains the values of elements with the given name
 * checked property set to true.
 */
HTMLFormElement.prototype.getChecked &#x3D; function(name, type) {
	var elements &#x3D; this.elements[name];
	if (!elements) {
		return [];
	}
	var return_array &#x3D; [];
	var i;
	if (elements instanceof HTMLSelectElement) {
		var options &#x3D; elements.options;
		for (i &#x3D; 0; i &amp;lt; options.length; ++i) {
			if (options[i].selected) {
				if (options[i].values) {
					return_array.push(options[i].values);
				} else {
					return_array.push(options[i].value);
				}

			}
		}
	} else if (elements instanceof HTMLInputElement) {
		if (type &amp;amp;&amp;amp; elements.type !&#x3D;&#x3D; type) {
			return [];
		} else if (elements.checked) {
			return [ elements.value ];
		}
	} else {
		for (i &#x3D; 0; i &amp;lt; elements.length; ++i) {
			if (elements[i].checked) {
				if (type &amp;amp;&amp;amp; elements[i].type !&#x3D;&#x3D; type) {
					continue;
				}
				if (elements[i].values) {
					return_array.push(elements[i].values);
				} else {
					return_array.push(elements[i].value);
				}
			}
		}
	}
	return return_array;
};

/**
 * Does the same as {@link HTMLFormElement.getChecked|getChecked}, but with unchecked elements.
 *
 * @function external:HTMLFormElement.getUnchecked
 * @param {string} name - Find checked property of elements (i.e. a checkbox
 * or a radiobutton) with the given name, or select options that have selected
 * set to true (don&#x27;t try to mix selects with radio/checkboxes).
 * @param {string} [type] - Optionally specify either radio or checkbox (for
 * the event that both checkboxes and radiobuttons have the same name).
 * @returns {string[]} - Contains the values of elements with the given name
 * checked property set to true.
 */
HTMLFormElement.prototype.getUnchecked &#x3D; function(name, type) {
	var elements &#x3D; this.elements[name];
	if (!elements) {
		return [];
	}
	var return_array &#x3D; [];
	var i;
	if (elements instanceof HTMLSelectElement) {
		var options &#x3D; elements.options;
		for (i &#x3D; 0; i &amp;lt; options.length; ++i) {
			if (!options[i].selected) {
				if (options[i].values) {
					return_array.push(options[i].values);
				} else {
					return_array.push(options[i].value);
				}

			}
		}
	} else if (elements instanceof HTMLInputElement) {
		if (type &amp;amp;&amp;amp; elements.type !&#x3D;&#x3D; type) {
			return [];
		} else if (!elements.checked) {
			return [ elements.value ];
		}
	} else {
		for (i &#x3D; 0; i &amp;lt; elements.length; ++i) {
			if (!elements[i].checked) {
				if (type &amp;amp;&amp;amp; elements[i].type !&#x3D;&#x3D; type) {
					continue;
				}
				if (elements[i].values) {
					return_array.push(elements[i].values);
				} else {
					return_array.push(elements[i].value);
				}
			}
		}
	}
	return return_array;
};


/**
 * @external RegExp
 */
/**
 * Deprecated as of September 2020, use {@link Morebits.string.escapeRegExp}
 * or &#x60;mw.util.escapeRegExp&#x60;.
 *
 * @function external:RegExp.escape
 * @deprecated Use {@link Morebits.string.escapeRegExp} or &#x60;mw.util.escapeRegExp&#x60;.
 * @param {string} text - String to be escaped.
 * @param {boolean} [space_fix&#x3D;false] - Whether to replace spaces and
 * underscores with &#x60;[ _]&#x60; as they are often equivalent.
 * @returns {string} - The escaped text.
 */
RegExp.escape &#x3D; function(text, space_fix) {
	if (space_fix) {
		console.error(&#x27;NOTE: RegExp.escape from Morebits was deprecated September 2020, please replace it with Morebits.string.escapeRegExp&#x27;); // eslint-disable-line no-console
		return Morebits.string.escapeRegExp(text);
	}
	console.error(&#x27;NOTE: RegExp.escape from Morebits was deprecated September 2020, please replace it with mw.util.escapeRegExp&#x27;); // eslint-disable-line no-console
	return mw.util.escapeRegExp(text);
};


/**
 * Helper functions to manipulate strings.
 *
 * @namespace Morebits.string
 * @memberof Morebits
 */
Morebits.string &#x3D; {
	/**
	 * @param {string} str
	 * @returns {string}
	 */
	toUpperCaseFirstChar: function(str) {
		str &#x3D; str.toString();
		return str.substr(0, 1).toUpperCase() + str.substr(1);
	},
	/**
	 * @param {string} str
	 * @returns {string}
	 */
	toLowerCaseFirstChar: function(str) {
		str &#x3D; str.toString();
		return str.substr(0, 1).toLowerCase() + str.substr(1);
	},

	/**
	 * Gives an array of substrings of &#x60;str&#x60; - starting with &#x60;start&#x60; and
	 * ending with &#x60;end&#x60; - which is not in &#x60;skiplist&#x60;.  Intended for use
	 * on wikitext with templates or links.
	 *
	 * @param {string} str
	 * @param {string} start
	 * @param {string} end
	 * @param {(string[]|string)} [skiplist]
	 * @returns {string[]}
	 * @throws If the &#x60;start&#x60; and &#x60;end&#x60; strings aren&#x27;t of the same length.
	 * @throws If &#x60;skiplist&#x60; isn&#x27;t an array or string
	 */
	splitWeightedByKeys: function(str, start, end, skiplist) {
		if (start.length !&#x3D;&#x3D; end.length) {
			throw new Error(&#x27;start marker and end marker must be of the same length&#x27;);
		}
		var level &#x3D; 0;
		var initial &#x3D; null;
		var result &#x3D; [];
		if (!Array.isArray(skiplist)) {
			if (skiplist &#x3D;&#x3D;&#x3D; undefined) {
				skiplist &#x3D; [];
			} else if (typeof skiplist &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
				skiplist &#x3D; [ skiplist ];
			} else {
				throw new Error(&#x27;non-applicable skiplist parameter&#x27;);
			}
		}
		for (var i &#x3D; 0; i &amp;lt; str.length; ++i) {
			for (var j &#x3D; 0; j &amp;lt; skiplist.length; ++j) {
				if (str.substr(i, skiplist[j].length) &#x3D;&#x3D;&#x3D; skiplist[j]) {
					i +&#x3D; skiplist[j].length - 1;
					continue;
				}
			}
			if (str.substr(i, start.length) &#x3D;&#x3D;&#x3D; start) {
				if (initial &#x3D;&#x3D;&#x3D; null) {
					initial &#x3D; i;
				}
				++level;
				i +&#x3D; start.length - 1;
			} else if (str.substr(i, end.length) &#x3D;&#x3D;&#x3D; end) {
				--level;
				i +&#x3D; end.length - 1;
			}
			if (!level &amp;amp;&amp;amp; initial !&#x3D;&#x3D; null) {
				result.push(str.substring(initial, i + 1));
				initial &#x3D; null;
			}
		}

		return result;
	},

	/**
	 * Formats freeform &quot;reason&quot; (from a textarea) for deletion/other
	 * templates that are going to be substituted, (e.g. PROD, XFD, RPP).
	 * Handles &#x60;|&#x60; outside a nowiki tag.
	 * Optionally, also adds a signature if not present already.
	 *
	 * @param {string} str
	 * @param {boolean} [addSig]
	 * @returns {string}
	 */
	formatReasonText: function(str, addSig) {
		var reason &#x3D; (str || &#x27;&#x27;).toString().trim();
		var unbinder &#x3D; new Morebits.unbinder(reason);
		unbinder.unbind(&#x27;&amp;lt;no&#x27; + &#x27;wiki&gt;&#x27;, &#x27;&amp;lt;/no&#x27; + &#x27;wiki&gt;&#x27;);
		unbinder.content &#x3D; unbinder.content.replace(/\|/g, &#x27;{{subst:!}}&#x27;);
		reason &#x3D; unbinder.rebind();
		if (addSig) {
			var sig &#x3D; &#x27;~~~~&#x27;, sigIndex &#x3D; reason.lastIndexOf(sig);
			if (sigIndex &#x3D;&#x3D;&#x3D; -1 || sigIndex !&#x3D;&#x3D; reason.length - sig.length) {
				reason +&#x3D; &#x27; &#x27; + sig;
			}
		}
		return reason.trim();
	},

	/**
	 * Formats a &quot;reason&quot; (from a textarea) for inclusion in a userspace
	 * log.  Replaces newlines with {{Pb}}, and adds an extra &#x60;#&#x60; before
	 * list items for proper formatting.
	 *
	 * @param {string} str
	 * @returns {string}
	 */
	formatReasonForLog: function(str) {
		return str
			// handle line breaks, which otherwise break numbering
			.replace(/\n+/g, &#x27;{{pb}}&#x27;)
			// put an extra # in front before bulleted or numbered list items
			.replace(/^(#+)/mg, &#x27;#$1&#x27;)
			.replace(/^(\*+)/mg, &#x27;#$1&#x27;);
	},

	/**
	 * Like &#x60;String.prototype.replace()&#x60;, but escapes any dollar signs in
	 * the replacement string.  Useful when the the replacement string is
	 * arbitrary, such as a username or freeform user input, and could
	 * contain dollar signs.
	 *
	 * @param {string} string - Text in which to replace.
	 * @param {(string|RegExp)} pattern
	 * @param {string} replacement
	 * @returns {string}
	 */
	safeReplace: function morebitsStringSafeReplace(string, pattern, replacement) {
		return string.replace(pattern, replacement.replace(/\$/g, &#x27;$$$$&#x27;));
	},

	/**
	 * Determine if the user-provided expiration will be considered an
	 * infinite-length by MW.
	 *
	 * @see {@link https://phabricator.wikimedia.org/T68646}
	 *
	 * @param {string} expiry
	 * @returns {boolean}
	 */
	isInfinity: function morebitsStringIsInfinity(expiry) {
		return [&#x27;indefinite&#x27;, &#x27;infinity&#x27;, &#x27;infinite&#x27;, &#x27;never&#x27;].indexOf(expiry) !&#x3D;&#x3D; -1;
	},

	/**
	 * Escapes a string to be used in a RegExp, replacing spaces and
	 * underscores with &#x60;[_ ]&#x60; as they are often equivalent.
	 * Replaced RegExp.escape September 2020.
	 *
	 * @param {string} text - String to be escaped.
	 * @returns {string} - The escaped text.
	 */
	escapeRegExp: function(text) {
		return mw.util.escapeRegExp(text).replace(/ |_/g, &#x27;[_ ]&#x27;);
	}
};


/**
 * Helper functions to manipulate arrays.
 *
 * @namespace Morebits.array
 * @memberof Morebits
 */
Morebits.array &#x3D; {
	/**
	 * Remove duplicated items from an array.
	 *
	 * @param {Array} arr
	 * @returns {Array} A copy of the array with duplicates removed.
	 * @throws When provided a non-array.
	 */
	uniq: function(arr) {
		if (!Array.isArray(arr)) {
			throw &#x27;A non-array object passed to Morebits.array.uniq&#x27;;
		}
		return arr.filter(function(item, idx) {
			return arr.indexOf(item) &#x3D;&#x3D;&#x3D; idx;
		});
	},

	/**
	 * Remove non-duplicated items from an array.
	 *
	 * @param {Array} arr
	 * @returns {Array} A copy of the array with the first instance of each value
	 * removed; subsequent instances of those values (duplicates) remain.
	 * @throws When provided a non-array.
	 */
	dups: function(arr) {
		if (!Array.isArray(arr)) {
			throw &#x27;A non-array object passed to Morebits.array.dups&#x27;;
		}
		return arr.filter(function(item, idx) {
			return arr.indexOf(item) !&#x3D;&#x3D; idx;
		});
	},


	/**
	 * Break up an array into smaller arrays.
	 *
	 * @param {Array} arr
	 * @param {number} size - Size of each chunk (except the last, which could be different).
	 * @returns {Array[]} An array containing the smaller, chunked arrays.
	 * @throws When provided a non-array.
	 */
	chunk: function(arr, size) {
		if (!Array.isArray(arr)) {
			throw &#x27;A non-array object passed to Morebits.array.chunk&#x27;;
		}
		if (typeof size !&#x3D;&#x3D; &#x27;number&#x27; || size &amp;lt;&#x3D; 0) { // pretty impossible to do anything :)
			return [ arr ]; // we return an array consisting of this array.
		}
		var numChunks &#x3D; Math.ceil(arr.length / size);
		var result &#x3D; new Array(numChunks);
		for (var i &#x3D; 0; i &amp;lt; numChunks; i++) {
			result[i] &#x3D; arr.slice(i * size, (i + 1) * size);
		}
		return result;
	}
};

/**
 * Utilities to enhance select2 menus. See twinklewarn, twinklexfd,
 * twinkleblock for sample usages.
 *
 * @see {@link https://select2.org/}
 *
 * @namespace Morebits.select2
 * @memberof Morebits
 * @requires jquery.select2
 */
Morebits.select2 &#x3D; {
	matchers: {
		/**
		 * Custom matcher in which if the optgroup name matches, all options in that
		 * group are shown, like in jquery.chosen.
		 */
		optgroupFull: function(params, data) {
			var originalMatcher &#x3D; $.fn.select2.defaults.defaults.matcher;
			var result &#x3D; originalMatcher(params, data);

			if (result &amp;amp;&amp;amp; params.term &amp;amp;&amp;amp;
				data.text.toUpperCase().indexOf(params.term.toUpperCase()) !&#x3D;&#x3D; -1) {
				result.children &#x3D; data.children;
			}
			return result;
		},

		/** Custom matcher that matches from the beginning of words only. */
		wordBeginning: function(params, data) {
			var originalMatcher &#x3D; $.fn.select2.defaults.defaults.matcher;
			var result &#x3D; originalMatcher(params, data);
			if (!params.term || (result &amp;amp;&amp;amp;
				new RegExp(&#x27;\\b&#x27; + mw.util.escapeRegExp(params.term), &#x27;i&#x27;).test(result.text))) {
				return result;
			}
			return null;
		}
	},

	/** Underline matched part of options. */
	highlightSearchMatches: function(data) {
		var searchTerm &#x3D; Morebits.select2SearchQuery;
		if (!searchTerm || data.loading) {
			return data.text;
		}
		var idx &#x3D; data.text.toUpperCase().indexOf(searchTerm.toUpperCase());
		if (idx &amp;lt; 0) {
			return data.text;
		}

		return $(&#x27;&amp;lt;span&gt;&#x27;).append(
			data.text.slice(0, idx),
			$(&#x27;&amp;lt;span&gt;&#x27;).css(&#x27;text-decoration&#x27;, &#x27;underline&#x27;).text(data.text.slice(idx, idx + searchTerm.length)),
			data.text.slice(idx + searchTerm.length)
		);
	},

	/** Intercept query as it is happening, for use in highlightSearchMatches. */
	queryInterceptor: function(params) {
		Morebits.select2SearchQuery &#x3D; params &amp;amp;&amp;amp; params.term;
	},

	/**
	 * Open dropdown and begin search when the &#x60;.select2-selection&#x60; has
	 * focus and a key is pressed.
	 *
	 * @see {@link https://github.com/select2/select2/issues/3279#issuecomment-442524147}
	 */
	autoStart: function(ev) {
		if (ev.which &amp;lt; 48) {
			return;
		}
		var target &#x3D; $(ev.target).closest(&#x27;.select2-container&#x27;);
		if (!target.length) {
			return;
		}
		target &#x3D; target.prev();
		target.select2(&#x27;open&#x27;);
		var search &#x3D; target.data(&#x27;select2&#x27;).dropdown.$search ||
			target.data(&#x27;select2&#x27;).selection.$search;
		search.focus();
	}

};


/**
 * Temporarily hide a part of a string while processing the rest of it.
 * Used by {@link Morebits.wikitext.page#commentOutImage|Morebits.wikitext.page.commentOutImage}.
 *
 * @memberof Morebits
 * @class
 * @param {string} string - The initial text to process.
 * @example var u &#x3D; new Morebits.unbinder(&#x27;Hello world &amp;lt;!-- world --&gt; world&#x27;);
 * u.unbind(&#x27;&amp;lt;!--&#x27;, &#x27;--&gt;&#x27;); // text inside comment remains intact
 * u.content &#x3D; u.content.replace(/world/g, &#x27;earth&#x27;);
 * u.rebind(); // gives &#x27;Hello earth &amp;lt;!-- world --&gt; earth&#x27;
 */
Morebits.unbinder &#x3D; function Unbinder(string) {
	if (typeof string !&#x3D;&#x3D; &#x27;string&#x27;) {
		throw new Error(&#x27;not a string&#x27;);
	}
	/** The text being processed. */
	this.content &#x3D; string;
	this.counter &#x3D; 0;
	this.history &#x3D; {};
	this.prefix &#x3D; &#x27;%UNIQ::&#x27; + Math.random() + &#x27;::&#x27;;
	this.postfix &#x3D; &#x27;::UNIQ%&#x27;;
};

Morebits.unbinder.prototype &#x3D; {
	/**
	 * Hide the region encapsulated by the &#x60;prefix&#x60; and &#x60;postfix&#x60; from
	 * string processing.  &#x60;prefix&#x60; and &#x60;postfix&#x60; will be used in a
	 * RegExp, so items that need escaping should be use &#x60;\\&#x60;.
	 *
	 * @param {string} prefix
	 * @param {string} postfix
	 * @throws If either &#x60;prefix&#x60; or &#x60;postfix&#x60; is missing.
	 */
	unbind: function UnbinderUnbind(prefix, postfix) {
		if (!prefix || !postfix) {
			throw new Error(&#x27;Both prefix and postfix must be provided&#x27;);
		}
		var re &#x3D; new RegExp(prefix + &#x27;([\\s\\S]*?)&#x27; + postfix, &#x27;g&#x27;);
		this.content &#x3D; this.content.replace(re, Morebits.unbinder.getCallback(this));
	},

	/**
	 * Restore the hidden portion of the &#x60;content&#x60; string.
	 *
	 * @returns {string} The processed output.
	 */
	rebind: function UnbinderRebind() {
		var content &#x3D; this.content;
		content.self &#x3D; this;
		for (var current in this.history) {
			if (Object.prototype.hasOwnProperty.call(this.history, current)) {
				content &#x3D; content.replace(current, this.history[current]);
			}
		}
		return content;
	},
	prefix: null, // %UNIQ::0.5955981644938324::
	postfix: null, // ::UNIQ%
	content: null, // string
	counter: null, // 0++
	history: null // {}
};
/** @memberof Morebits.unbinder */
Morebits.unbinder.getCallback &#x3D; function UnbinderGetCallback(self) {
	return function UnbinderCallback(match) {
		var current &#x3D; self.prefix + self.counter + self.postfix;
		self.history[current] &#x3D; match;
		++self.counter;
		return current;
	};
};



/* **************** Morebits.date **************** */
/**
 * Create a date object with enhanced processing capabilities, a la
 * {@link https://momentjs.com/|moment.js}. MediaWiki timestamp format is also
 * acceptable, in addition to everything that JS Date() accepts.
 *
 * @memberof Morebits
 * @class
 */
Morebits.date &#x3D; function() {
	var args &#x3D; Array.prototype.slice.call(arguments);

	// Check MediaWiki formats
	// Must be first since firefox erroneously accepts the timestamp
	// format, sans timezone (See also: #921, #936, #1174, #1187), and the
	// 14-digit string will be interpreted differently.
	if (args.length &#x3D;&#x3D;&#x3D; 1) {
		var param &#x3D; args[0];
		if (/^\d{14}$/.test(param)) {
			// YYYYMMDDHHmmss
			var digitMatch &#x3D; /(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/.exec(param);
			if (digitMatch) {
				// ..... year ... month .. date ... hour .... minute ..... second
				this._d &#x3D; new Date(Date.UTC.apply(null, [digitMatch[1], digitMatch[2] - 1, digitMatch[3], digitMatch[4], digitMatch[5], digitMatch[6]]));
			}
		} else if (typeof param &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
			// Wikitext signature timestamp
			var dateParts &#x3D; Morebits.date.localeData.signatureTimestampFormat(param);
			if (dateParts) {
				this._d &#x3D; new Date(Date.UTC.apply(null, dateParts));
			}
		}
	}

	if (!this._d) {
		// Try standard date
		this._d &#x3D; new (Function.prototype.bind.apply(Date, [Date].concat(args)));
	}

	// Still no?
	if (!this.isValid()) {
		mw.log.warn(&#x27;Invalid Morebits.date initialisation:&#x27;, args);
	}
};

/**
 * Localized strings for date processing.
 *
 * @memberof Morebits.date
 * @type {object.&amp;lt;string, string&gt;}
 * @property {string[]} months
 * @property {string[]} monthsShort
 * @property {string[]} days
 * @property {string[]} daysShort
 * @property {object.&amp;lt;string, string&gt;} relativeTimes
 * @private
 */
Morebits.date.localeData &#x3D; {
	months: [&#x27;January&#x27;, &#x27;February&#x27;, &#x27;March&#x27;, &#x27;April&#x27;, &#x27;May&#x27;, &#x27;June&#x27;, &#x27;July&#x27;, &#x27;August&#x27;, &#x27;September&#x27;, &#x27;October&#x27;, &#x27;November&#x27;, &#x27;December&#x27;],
	monthsShort: [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;],
	days: [&#x27;Sunday&#x27;, &#x27;Monday&#x27;, &#x27;Tuesday&#x27;, &#x27;Wednesday&#x27;, &#x27;Thursday&#x27;, &#x27;Friday&#x27;, &#x27;Saturday&#x27;],
	daysShort: [&#x27;Sun&#x27;, &#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;],
	relativeTimes: {
		thisDay: &#x27;[Today at] h:mm A&#x27;,
		prevDay: &#x27;[Yesterday at] h:mm A&#x27;,
		nextDay: &#x27;[Tomorrow at] h:mm A&#x27;,
		thisWeek: &#x27;dddd [at] h:mm A&#x27;,
		pastWeek: &#x27;[Last] dddd [at] h:mm A&#x27;,
		other: &#x27;YYYY-MM-DD&#x27;
	},
	signatureTimestampFormat: function (str) {
		// HH:mm, DD Month YYYY (UTC)
		var rgx &#x3D; /(\d{2}):(\d{2}), (\d{1,2}) (\w+) (\d{4}) \(UTC\)/;
		var match &#x3D; rgx.exec(str);
		if (!match) {
			return null;
		}
		var month &#x3D; Morebits.date.localeData.months.indexOf(match[4]);
		if (month &#x3D;&#x3D;&#x3D; -1) {
			return null;
		}
		// ..... year ... month .. date ... hour .... minute
		return [match[5], month, match[3], match[1], match[2]];
	}
};

Morebits.date.prototype &#x3D; {
	/** @returns {boolean} */
	isValid: function() {
		return !isNaN(this.getTime());
	},

	/**
	 * @param {(Date|Morebits.date)} date
	 * @returns {boolean}
	 */
	isBefore: function(date) {
		return this.getTime() &amp;lt; date.getTime();
	},
	/**
	 * @param {(Date|Morebits.date)} date
	 * @returns {boolean}
	 */
	isAfter: function(date) {
		return this.getTime() &gt; date.getTime();
	},

	/** @returns {string} */
	getUTCMonthName: function() {
		return Morebits.date.localeData.months[this.getUTCMonth()];
	},
	/** @returns {string} */
	getUTCMonthNameAbbrev: function() {
		return Morebits.date.localeData.monthsShort[this.getUTCMonth()];
	},
	/** @returns {string} */
	getMonthName: function() {
		return Morebits.date.localeData.months[this.getMonth()];
	},
	/** @returns {string} */
	getMonthNameAbbrev: function() {
		return Morebits.date.localeData.monthsShort[this.getMonth()];
	},
	/** @returns {string} */
	getUTCDayName: function() {
		return Morebits.date.localeData.days[this.getUTCDay()];
	},
	/** @returns {string} */
	getUTCDayNameAbbrev: function() {
		return Morebits.date.localeData.daysShort[this.getUTCDay()];
	},
	/** @returns {string} */
	getDayName: function() {
		return Morebits.date.localeData.days[this.getDay()];
	},
	/** @returns {string} */
	getDayNameAbbrev: function() {
		return Morebits.date.localeData.daysShort[this.getDay()];
	},

	/**
	 * Add a given number of minutes, hours, days, months or years to the date.
	 * This is done in-place. The modified date object is also returned, allowing chaining.
	 *
	 * @param {number} number - Should be an integer.
	 * @param {string} unit
	 * @throws If invalid or unsupported unit is given.
	 * @returns {Morebits.date}
	 */
	add: function(number, unit) {
		// mapping time units with getter/setter function names
		var unitMap &#x3D; {
			seconds: &#x27;Seconds&#x27;,
			minutes: &#x27;Minutes&#x27;,
			hours: &#x27;Hours&#x27;,
			days: &#x27;Date&#x27;,
			months: &#x27;Month&#x27;,
			years: &#x27;FullYear&#x27;
		};
		var unitNorm &#x3D; unitMap[unit] || unitMap[unit + &#x27;s&#x27;]; // so that both singular and  plural forms work
		if (unitNorm) {
			this[&#x27;set&#x27; + unitNorm](this[&#x27;get&#x27; + unitNorm]() + number);
			return this;
		}
		throw new Error(&#x27;Invalid unit &quot;&#x27; + unit + &#x27;&quot;: Only &#x27; + Object.keys(unitMap).join(&#x27;, &#x27;) + &#x27; are allowed.&#x27;);
	},

	/**
	 * Subtracts a given number of minutes, hours, days, months or years to the date.
	 * This is done in-place. The modified date object is also returned, allowing chaining.
	 *
	 * @param {number} number - Should be an integer.
	 * @param {string} unit
	 * @throws If invalid or unsupported unit is given.
	 * @returns {Morebits.date}
	 */
	subtract: function(number, unit) {
		return this.add(-number, unit);
	},

	/**
	 * Format the date into a string per the given format string.
	 * Replacement syntax is a subset of that in moment.js:
	 *
	 * | Syntax | Output |
	 * |--------|--------|
	 * | H | Hours (24-hour) |
	 * | HH | Hours (24-hour, padded) |
	 * | h | Hours (12-hour) |
	 * | hh | Hours (12-hour, padded) |
	 * | A | AM or PM |
	 * | m | Minutes |
	 * | mm | Minutes (padded) |
	 * | s | Seconds |
	 * | ss | Seconds (padded) |
	 * | SSS | Milliseconds fragment, padded |
	 * | d | Day number of the week (Sun&#x3D;0) |
	 * | ddd | Abbreviated day name |
	 * | dddd | Full day name |
	 * | D | Date |
	 * | DD | Date (padded) |
	 * | M | Month number (0-indexed) |
	 * | MM | Month number (0-indexed, padded) |
	 * | MMM | Abbreviated month name |
	 * | MMMM | Full month name |
	 * | Y | Year |
	 * | YY | Final two digits of year (20 for 2020, 42 for 1942) |
	 * | YYYY | Year (same as &#x60;Y&#x60;) |
	 *
	 * @param {string} formatstr - Format the date into a string, using
	 * the replacement syntax.  Use &#x60;[&#x60; and &#x60;]&#x60; to escape items.  If not
	 * provided, will return the ISO-8601-formatted string.
	 * @param {(string|number)} [zone&#x3D;system] - &#x60;system&#x60; (for browser-default time zone),
	 * &#x60;utc&#x60;, or specify a time zone as number of minutes relative to UTC.
	 * @returns {string}
	 */
	format: function(formatstr, zone) {
		if (!this.isValid()) {
			return &#x27;Invalid date&#x27;; // Put the truth out, preferable to &quot;NaNNaNNan NaN:NaN&quot; or whatever
		}
		var udate &#x3D; this;
		// create a new date object that will contain the date to display as system time
		if (zone &#x3D;&#x3D;&#x3D; &#x27;utc&#x27;) {
			udate &#x3D; new Morebits.date(this.getTime()).add(this.getTimezoneOffset(), &#x27;minutes&#x27;);
		} else if (typeof zone &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
			// convert to utc, then add the utc offset given
			udate &#x3D; new Morebits.date(this.getTime()).add(this.getTimezoneOffset() + zone, &#x27;minutes&#x27;);
		}

		// default to ISOString
		if (!formatstr) {
			return udate.toISOString();
		}

		var pad &#x3D; function(num, len) {
			len &#x3D; len || 2; // Up to length of 00 + 1
			return (&#x27;00&#x27; + num).toString().slice(0 - len);
		};
		var h24 &#x3D; udate.getHours(), m &#x3D; udate.getMinutes(), s &#x3D; udate.getSeconds(), ms &#x3D; udate.getMilliseconds();
		var D &#x3D; udate.getDate(), M &#x3D; udate.getMonth() + 1, Y &#x3D; udate.getFullYear();
		var h12 &#x3D; h24 % 12 || 12, amOrPm &#x3D; h24 &gt;&#x3D; 12 ? &#x27;PM&#x27; : &#x27;AM&#x27;;
		var replacementMap &#x3D; {
			HH: pad(h24), H: h24, hh: pad(h12), h: h12, A: amOrPm,
			mm: pad(m), m: m,
			ss: pad(s), s: s,
			SSS: pad(ms, 3),
			dddd: udate.getDayName(), ddd: udate.getDayNameAbbrev(), d: udate.getDay(),
			DD: pad(D), D: D,
			MMMM: udate.getMonthName(), MMM: udate.getMonthNameAbbrev(), MM: pad(M), M: M,
			YYYY: Y, YY: pad(Y % 100), Y: Y
		};

		var unbinder &#x3D; new Morebits.unbinder(formatstr); // escape stuff between [...]
		unbinder.unbind(&#x27;\\[&#x27;, &#x27;\\]&#x27;);
		unbinder.content &#x3D; unbinder.content.replace(
			/* Regex notes:
			 * d(d{2,3})? matches exactly 1, 3 or 4 occurrences of &#x27;d&#x27; (&#x27;dd&#x27; is treated as a double match of &#x27;d&#x27;)
			 * Y{1,2}(Y{2})? matches exactly 1, 2 or 4 occurrences of &#x27;Y&#x27;
			 */
			/H{1,2}|h{1,2}|m{1,2}|s{1,2}|SSS|d(d{2,3})?|D{1,2}|M{1,4}|Y{1,2}(Y{2})?|A/g,
			function(match) {
				return replacementMap[match];
			}
		);
		return unbinder.rebind().replace(/\[(.*?)\]/g, &#x27;$1&#x27;);
	},

	/**
	 * Gives a readable relative time string such as &quot;Yesterday at 6:43 PM&quot; or &quot;Last Thursday at 11:45 AM&quot;.
	 * Similar to &#x60;calendar&#x60; in moment.js, but with time zone support.
	 *
	 * @param {(string|number)} [zone&#x3D;system] - &#x27;system&#x27; (for browser-default time zone),
	 * &#x27;utc&#x27; (for UTC), or specify a time zone as number of minutes past UTC.
	 * @returns {string}
	 */
	calendar: function(zone) {
		// Zero out the hours, minutes, seconds and milliseconds - keeping only the date;
		// find the difference. Note that setHours() returns the same thing as getTime().
		var dateDiff &#x3D; (new Date().setHours(0, 0, 0, 0) -
			new Date(this).setHours(0, 0, 0, 0)) / 8.64e7;
		switch (true) {
			case dateDiff &#x3D;&#x3D;&#x3D; 0:
				return this.format(Morebits.date.localeData.relativeTimes.thisDay, zone);
			case dateDiff &#x3D;&#x3D;&#x3D; 1:
				return this.format(Morebits.date.localeData.relativeTimes.prevDay, zone);
			case dateDiff &gt; 0 &amp;amp;&amp;amp; dateDiff &amp;lt; 7:
				return this.format(Morebits.date.localeData.relativeTimes.pastWeek, zone);
			case dateDiff &#x3D;&#x3D;&#x3D; -1:
				return this.format(Morebits.date.localeData.relativeTimes.nextDay, zone);
			case dateDiff &amp;lt; 0 &amp;amp;&amp;amp; dateDiff &gt; -7:
				return this.format(Morebits.date.localeData.relativeTimes.thisWeek, zone);
			default:
				return this.format(Morebits.date.localeData.relativeTimes.other, zone);
		}
	},

	/**
	 * Get a regular expression that matches wikitext section titles, such
	 * as &#x60;&#x3D;&#x3D;December 2019&#x3D;&#x3D;&#x60; or &#x60;&#x3D;&#x3D;&#x3D; Jan 2018 &#x3D;&#x3D;&#x3D;&#x60;.
	 *
	 * @returns {RegExp}
	 */
	monthHeaderRegex: function() {
		return new RegExp(&#x27;^(&#x3D;&#x3D;+)\\s*(?:&#x27; + this.getUTCMonthName() + &#x27;|&#x27; + this.getUTCMonthNameAbbrev() +
			&#x27;)\\s+&#x27; + this.getUTCFullYear() + &#x27;\\s*\\1&#x27;, &#x27;mg&#x27;);
	},

	/**
	 * Creates a wikitext section header with the month and year.
	 *
	 * @param {number} [level&#x3D;2] - Header level.  Pass 0 for just the text
	 * with no wikitext markers (&#x3D;&#x3D;).
	 * @returns {string}
	 */
	monthHeader: function(level) {
		// Default to 2, but allow for 0 or stringy numbers
		level &#x3D; parseInt(level, 10);
		level &#x3D; isNaN(level) ? 2 : level;

		var header &#x3D; Array(level + 1).join(&#x27;&#x3D;&#x27;); // String.prototype.repeat not supported in IE 11
		var text &#x3D; this.getUTCMonthName() + &#x27; &#x27; + this.getUTCFullYear();

		if (header.length) { // wikitext-formatted header
			return header + &#x27; &#x27; + text + &#x27; &#x27; + header;
		}
		return text; // Just the string

	}

};

// Allow native Date.prototype methods to be used on Morebits.date objects
Object.getOwnPropertyNames(Date.prototype).forEach(function(func) {
	// Exclude methods that collide with PageTriage&#x27;s Date.js external, which clobbers native Date: [[phab:T268513]]
	if ([&#x27;add&#x27;, &#x27;getDayName&#x27;, &#x27;getMonthName&#x27;].indexOf(func) &#x3D;&#x3D;&#x3D; -1) {
		Morebits.date.prototype[func] &#x3D; function() {
			return this._d[func].apply(this._d, Array.prototype.slice.call(arguments));
		};
	}
});


/* **************** Morebits.wiki **************** */
/**
 * Various objects for wiki editing and API access, including
 * {@link Morebits.wiki.api} and {@link Morebits.wiki.page}.
 *
 * @namespace Morebits.wiki
 * @memberof Morebits
 */
Morebits.wiki &#x3D; {};

/**
 * @deprecated in favor of Morebits.isPageRedirect as of November 2020
 * @memberof Morebits.wiki
 * @returns {boolean}
 */
Morebits.wiki.isPageRedirect &#x3D; function wikipediaIsPageRedirect() {
	console.warn(&#x27;NOTE: Morebits.wiki.isPageRedirect has been deprecated, use Morebits.isPageRedirect instead.&#x27;); // eslint-disable-line no-console
	return Morebits.isPageRedirect();
};


/* **************** Morebits.wiki.actionCompleted **************** */
/**
 * @memberof Morebits.wiki
 * @type {number}
 */
Morebits.wiki.numberOfActionsLeft &#x3D; 0;
/**
 * @memberof Morebits.wiki
 * @type {number}
 */
Morebits.wiki.nbrOfCheckpointsLeft &#x3D; 0;

/**
 * Display message and/or redirect to page upon completion of tasks.
 *
 * Every call to Morebits.wiki.api.post() results in the dispatch of an
 * asynchronous callback. Each callback can in turn make an additional call to
 * Morebits.wiki.api.post() to continue a processing sequence. At the
 * conclusion of the final callback of a processing sequence, it is not
 * possible to simply return to the original caller because there is no call
 * stack leading back to the original context. Instead,
 * Morebits.wiki.actionCompleted.event() is called to display the result to
 * the user and to perform an optional page redirect.
 *
 * The determination of when to call Morebits.wiki.actionCompleted.event() is
 * managed through the globals Morebits.wiki.numberOfActionsLeft and
 * Morebits.wiki.nbrOfCheckpointsLeft. Morebits.wiki.numberOfActionsLeft is
 * incremented at the start of every Morebits.wiki.api call and decremented
 * after the completion of a callback function. If a callback function does
 * not create a new Morebits.wiki.api object before exiting, it is the final
 * step in the processing chain and Morebits.wiki.actionCompleted.event() will
 * then be called.
 *
 * Optionally, callers may use Morebits.wiki.addCheckpoint() to indicate that
 * processing is not complete upon the conclusion of the final callback
 * function.  This is used for batch operations. The end of a batch is
 * signaled by calling Morebits.wiki.removeCheckpoint().
 *
 * @memberof Morebits.wiki
 */
Morebits.wiki.actionCompleted &#x3D; function(self) {
	if (--Morebits.wiki.numberOfActionsLeft &amp;lt;&#x3D; 0 &amp;amp;&amp;amp; Morebits.wiki.nbrOfCheckpointsLeft &amp;lt;&#x3D; 0) {
		Morebits.wiki.actionCompleted.event(self);
	}
};

// Change per action wanted
/** @memberof Morebits.wiki */
Morebits.wiki.actionCompleted.event &#x3D; function() {
	if (Morebits.wiki.actionCompleted.notice) {
		Morebits.status.actionCompleted(Morebits.wiki.actionCompleted.notice);
	}
	if (Morebits.wiki.actionCompleted.redirect) {
		// if it isn&#x27;t a URL, make it one. TODO: This breaks on the articles &#x27;http://&#x27;, &#x27;ftp://&#x27;, and similar ones.
		if (!(/^\w+:\/\//).test(Morebits.wiki.actionCompleted.redirect)) {
			Morebits.wiki.actionCompleted.redirect &#x3D; mw.util.getUrl(Morebits.wiki.actionCompleted.redirect);
			if (Morebits.wiki.actionCompleted.followRedirect &#x3D;&#x3D;&#x3D; false) {
				Morebits.wiki.actionCompleted.redirect +&#x3D; &#x27;?redirect&#x3D;no&#x27;;
			}
		}
		window.setTimeout(function() {
			window.location &#x3D; Morebits.wiki.actionCompleted.redirect;
		}, Morebits.wiki.actionCompleted.timeOut);
	}
};

/** @memberof Morebits.wiki */
Morebits.wiki.actionCompleted.timeOut &#x3D; typeof window.wpActionCompletedTimeOut &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; ? 5000 : window.wpActionCompletedTimeOut;
/** @memberof Morebits.wiki */
Morebits.wiki.actionCompleted.redirect &#x3D; null;
/** @memberof Morebits.wiki */
Morebits.wiki.actionCompleted.notice &#x3D; null;

/** @memberof Morebits.wiki */
Morebits.wiki.addCheckpoint &#x3D; function() {
	++Morebits.wiki.nbrOfCheckpointsLeft;
};

/** @memberof Morebits.wiki */
Morebits.wiki.removeCheckpoint &#x3D; function() {
	if (--Morebits.wiki.nbrOfCheckpointsLeft &amp;lt;&#x3D; 0 &amp;amp;&amp;amp; Morebits.wiki.numberOfActionsLeft &amp;lt;&#x3D; 0) {
		Morebits.wiki.actionCompleted.event();
	}
};


/* **************** Morebits.wiki.api **************** */
/**
 * An easy way to talk to the MediaWiki API.  Accepts either json or xml
 * (default) formats; if json is selected, will default to &#x60;formatversion&#x3D;2&#x60;
 * unless otherwise specified.  Similarly, enforces newer &#x60;errorformat&#x60;s,
 * defaulting to &#x60;html&#x60; if unspecified.  &#x60;uselang&#x60; enforced to the wiki&#x27;s
 * content language.
 *
 * In new code, the use of the last 3 parameters should be avoided, instead
 * use {@link Morebits.wiki.api#setStatusElement|setStatusElement()} to bind
 * the status element (if needed) and use &#x60;.then()&#x60; or &#x60;.catch()&#x60; on the
 * promise returned by &#x60;post()&#x60;, rather than specify the &#x60;onSuccess&#x60; or
 * &#x60;onFailure&#x60; callbacks.
 *
 * @memberof Morebits.wiki
 * @class
 * @param {string} currentAction - The current action (required).
 * @param {object} query - The query (required).
 * @param {Function} [onSuccess] - The function to call when request is successful.
 * @param {Morebits.status} [statusElement] - A Morebits.status object to use for status messages.
 * @param {Function} [onError] - The function to call if an error occurs.
 */
Morebits.wiki.api &#x3D; function(currentAction, query, onSuccess, statusElement, onError) {
	this.currentAction &#x3D; currentAction;
	this.query &#x3D; query;
	this.query.assert &#x3D; &#x27;user&#x27;;
	// Enforce newer error formats, preferring html
	if (!query.errorformat || [&#x27;wikitext&#x27;, &#x27;plaintext&#x27;].indexOf(query.errorformat) &#x3D;&#x3D;&#x3D; -1) {
		this.query.errorformat &#x3D; &#x27;html&#x27;;
	}
	// Explicitly use the wiki&#x27;s content language to minimize confusion,
	// see #1179 for discussion
	this.query.uselang &#x3D; &#x27;content&#x27;;
	this.query.errorlang &#x3D; &#x27;uselang&#x27;;
	this.query.errorsuselocal &#x3D; 1;

	this.onSuccess &#x3D; onSuccess;
	this.onError &#x3D; onError;
	if (statusElement) {
		this.setStatusElement(statusElement);
	} else {
		this.statelem &#x3D; new Morebits.status(currentAction);
	}
	// JSON is used throughout Morebits/Twinkle, but xml remains the default for backwards compatibility
	if (!query.format) {
		this.query.format &#x3D; &#x27;xml&#x27;;
	} else if (query.format &#x3D;&#x3D;&#x3D; &#x27;json&#x27; &amp;amp;&amp;amp; !query.formatversion) {
		this.query.formatversion &#x3D; &#x27;2&#x27;;
	} else if ([&#x27;xml&#x27;, &#x27;json&#x27;].indexOf(query.format) &#x3D;&#x3D;&#x3D; -1) {
		this.statelem.error(&#x27;Invalid API format: only xml and json are supported.&#x27;);
	}

	// Ignore tags for queries and most common unsupported actions, produces warnings
	if (query.action &amp;amp;&amp;amp; [&#x27;query&#x27;, &#x27;review&#x27;, &#x27;stabilize&#x27;, &#x27;pagetriageaction&#x27;, &#x27;watch&#x27;].indexOf(query.action) !&#x3D;&#x3D; -1) {
		delete query.tags;
	} else if (!query.tags &amp;amp;&amp;amp; morebitsWikiChangeTag) {
		query.tags &#x3D; morebitsWikiChangeTag;
	}
};

Morebits.wiki.api.prototype &#x3D; {
	currentAction: &#x27;&#x27;,
	onSuccess: null,
	onError: null,
	parent: window,  // use global context if there is no parent object
	query: null,
	response: null,
	responseXML: null,  // use &#x60;response&#x60; instead; retained for backwards compatibility
	statelem: null,  // this non-standard name kept for backwards compatibility
	statusText: null, // result received from the API, normally &quot;success&quot; or &quot;error&quot;
	errorCode: null, // short text error code, if any, as documented in the MediaWiki API
	errorText: null, // full error description, if any
	badtokenRetry: false, // set to true if this on a retry attempted after a badtoken error

	/**
	 * Keep track of parent object for callbacks.
	 *
	 * @param {*} parent
	 */
	setParent: function(parent) {
		this.parent &#x3D; parent;
	},

	/** @param {Morebits.status} statusElement */
	setStatusElement: function(statusElement) {
		this.statelem &#x3D; statusElement;
		this.statelem.status(this.currentAction);
	},

	/**
	 * Carry out the request.
	 *
	 * @param {object} callerAjaxParameters - Do not specify a parameter unless you really
	 * really want to give jQuery some extra parameters.
	 * @returns {promise} - A jQuery promise object that is resolved or rejected with the api object.
	 */
	post: function(callerAjaxParameters) {

		++Morebits.wiki.numberOfActionsLeft;

		var queryString &#x3D; $.map(this.query, function(val, i) {
			if (Array.isArray(val)) {
				return encodeURIComponent(i) + &#x27;&#x3D;&#x27; + val.map(encodeURIComponent).join(&#x27;|&#x27;);
			} else if (val !&#x3D;&#x3D; undefined) {
				return encodeURIComponent(i) + &#x27;&#x3D;&#x27; + encodeURIComponent(val);
			}
		}).join(&#x27;&amp;amp;&#x27;).replace(/^(.*?)(\btoken&#x3D;[^&amp;amp;]*)&amp;amp;(.*)/, &#x27;$1$3&amp;amp;$2&#x27;);
		// token should always be the last item in the query string (bug TW-B-0013)

		var ajaxparams &#x3D; $.extend({}, {
			context: this,
			type: this.query.action &#x3D;&#x3D;&#x3D; &#x27;query&#x27; ? &#x27;GET&#x27; : &#x27;POST&#x27;,
			url: mw.util.wikiScript(&#x27;api&#x27;),
			data: queryString,
			dataType: this.query.format,
			headers: {
				&#x27;Api-User-Agent&#x27;: morebitsWikiApiUserAgent
			}
		}, callerAjaxParameters);

		return $.ajax(ajaxparams).then(

			function onAPIsuccess(response, statusText) {
				this.statusText &#x3D; statusText;
				this.response &#x3D; this.responseXML &#x3D; response;
				// Limit to first error
				if (this.query.format &#x3D;&#x3D;&#x3D; &#x27;json&#x27;) {
					this.errorCode &#x3D; response.errors &amp;amp;&amp;amp; response.errors[0].code;
					if (this.query.errorformat &#x3D;&#x3D;&#x3D; &#x27;html&#x27;) {
						this.errorText &#x3D; response.errors &amp;amp;&amp;amp; response.errors[0].html;
					} else if (this.query.errorformat &#x3D;&#x3D;&#x3D; &#x27;wikitext&#x27; || this.query.errorformat &#x3D;&#x3D;&#x3D; &#x27;plaintext&#x27;) {
						this.errorText &#x3D; response.errors &amp;amp;&amp;amp; response.errors[0].text;
					}
				} else {
					this.errorCode &#x3D; $(response).find(&#x27;errors error&#x27;).eq(0).attr(&#x27;code&#x27;);
					// Sufficient for html, wikitext, or plaintext errorformats
					this.errorText &#x3D; $(response).find(&#x27;errors error&#x27;).eq(0).text();
				}

				if (typeof this.errorCode &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
					// the API didn&#x27;t like what we told it, e.g., bad edit token or an error creating a page
					return this.returnError(callerAjaxParameters);
				}

				// invoke success callback if one was supplied
				if (this.onSuccess) {
					// set the callback context to this.parent for new code and supply the API object
					// as the first argument to the callback (for legacy code)
					this.onSuccess.call(this.parent, this);
				} else {
					this.statelem.info(&#x27;done&#x27;);
				}

				Morebits.wiki.actionCompleted();

				return $.Deferred().resolveWith(this.parent, [this]);
			},

			// only network and server errors reach here - complaints from the API itself are caught in success()
			function onAPIfailure(jqXHR, statusText, errorThrown) {
				this.statusText &#x3D; statusText;
				this.errorThrown &#x3D; errorThrown; // frequently undefined
				this.errorText &#x3D; statusText + &#x27; &quot;&#x27; + jqXHR.statusText + &#x27;&quot; occurred while contacting the API.&#x27;;
				return this.returnError();
			}

		);
	},

	returnError: function(callerAjaxParameters) {
		if (this.errorCode &#x3D;&#x3D;&#x3D; &#x27;badtoken&#x27; &amp;amp;&amp;amp; !this.badtokenRetry) {
			this.statelem.warn(&#x27;Invalid token. Getting a new token and retrying...&#x27;);
			this.badtokenRetry &#x3D; true;
			// Get a new CSRF token and retry. If the original action needs a different
			// type of action than CSRF, we do one pointless retry before bailing out
			return Morebits.wiki.api.getToken().then(function(token) {
				this.query.token &#x3D; token;
				return this.post(callerAjaxParameters);
			}.bind(this));
		}

		this.statelem.error(this.errorText + &#x27; (&#x27; + this.errorCode + &#x27;)&#x27;);

		// invoke failure callback if one was supplied
		if (this.onError) {

			// set the callback context to this.parent for new code and supply the API object
			// as the first argument to the callback for legacy code
			this.onError.call(this.parent, this);
		}
		// don&#x27;t complete the action so that the error remains displayed

		return $.Deferred().rejectWith(this.parent, [this]);
	},

	getStatusElement: function() {
		return this.statelem;
	},

	getErrorCode: function() {
		return this.errorCode;
	},

	getErrorText: function() {
		return this.errorText;
	},

	getXML: function() { // retained for backwards compatibility, use getResponse() instead
		return this.responseXML;
	},

	getResponse: function() {
		return this.response;
	}

};

var morebitsWikiApiUserAgent &#x3D; &#x27;morebits.js ([[w:WT:TW]])&#x27;;
/**
 * Set the custom user agent header, which is used for server-side logging.
 * Note that doing so will set the useragent for every &#x60;Morebits.wiki.api&#x60;
 * process performed thereafter.
 *
 * @see {@link https://lists.wikimedia.org/pipermail/mediawiki-api-announce/2014-November/000075.html}
 * for original announcement.
 *
 * @memberof Morebits.wiki.api
 * @param {string} [ua&#x3D;morebits.js ([[w:WT:TW]])] - User agent.  The default
 * value of &#x60;morebits.js ([[w:WT:TW]])&#x60; will be appended to any provided
 * value.
 */
Morebits.wiki.api.setApiUserAgent &#x3D; function(ua) {
	morebitsWikiApiUserAgent &#x3D; (ua ? ua + &#x27; &#x27; : &#x27;&#x27;) + &#x27;morebits.js ([[w:WT:TW]])&#x27;;
};



/**
 * Change/revision tag applied to Morebits actions when no other tags are specified.
 * Unused by default per {@link https://en.wikipedia.org/w/index.php?oldid&#x3D;970618849#Adding_tags_to_Twinkle_edits_and_actions|EnWiki consensus}.
 *
 * @constant
 * @memberof Morebits.wiki.api
 * @type {string}
 */
var morebitsWikiChangeTag &#x3D; &#x27;&#x27;;


/**
 * Get a new CSRF token on encountering token errors.
 *
 * @memberof Morebits.wiki.api
 * @returns {string} MediaWiki CSRF token.
 */
Morebits.wiki.api.getToken &#x3D; function() {
	var tokenApi &#x3D; new Morebits.wiki.api(&#x27;Getting token&#x27;, {
		action: &#x27;query&#x27;,
		meta: &#x27;tokens&#x27;,
		type: &#x27;csrf&#x27;,
		format: &#x27;json&#x27;
	});
	return tokenApi.post().then(function(apiobj) {
		return apiobj.response.query.tokens.csrftoken;
	});
};


/* **************** Morebits.wiki.page **************** */
/**
 * Use the MediaWiki API to load a page and optionally edit it, move it, etc.
 *
 * Callers are not permitted to directly access the properties of this class!
 * All property access is through the appropriate get___() or set___() method.
 *
 * Callers should set {@link Morebits.wiki.actionCompleted.notice} and {@link Morebits.wiki.actionCompleted.redirect}
 * before the first call to {@link Morebits.wiki.page.load()}.
 *
 * Each of the callback functions takes one parameter, which is a
 * reference to the Morebits.wiki.page object that registered the callback.
 * Callback functions may invoke any Morebits.wiki.page prototype method using this reference.
 *
 *
 * Call sequence for common operations (optional final user callbacks not shown):
 *
 * - Edit current contents of a page (no edit conflict):
 * &#x60;.load(userTextEditCallback) -&gt; ctx.loadApi.post() -&gt;
 * ctx.loadApi.post.success() -&gt; ctx.fnLoadSuccess() -&gt; userTextEditCallback() -&gt;
 * .save() -&gt; ctx.saveApi.post() -&gt; ctx.loadApi.post.success() -&gt; ctx.fnSaveSuccess()&#x60;
 *
 * - Edit current contents of a page (with edit conflict):
 * &#x60;.load(userTextEditCallback) -&gt; ctx.loadApi.post() -&gt;
 * ctx.loadApi.post.success() -&gt; ctx.fnLoadSuccess() -&gt; userTextEditCallback() -&gt;
 * .save() -&gt; ctx.saveApi.post() -&gt; ctx.loadApi.post.success() -&gt;
 * ctx.fnSaveError() -&gt; ctx.loadApi.post() -&gt; ctx.loadApi.post.success() -&gt;
 * ctx.fnLoadSuccess() -&gt; userTextEditCallback() -&gt; .save() -&gt;
 * ctx.saveApi.post() -&gt; ctx.loadApi.post.success() -&gt; ctx.fnSaveSuccess()&#x60;
 *
 * - Append to a page (similar for prepend and newSection):
 * &#x60;.append() -&gt; ctx.loadApi.post() -&gt; ctx.loadApi.post.success() -&gt;
 * ctx.fnLoadSuccess() -&gt; ctx.fnAutoSave() -&gt; .save() -&gt; ctx.saveApi.post() -&gt;
 * ctx.loadApi.post.success() -&gt; ctx.fnSaveSuccess()&#x60;
 *
 * Notes:
 * 1. All functions following Morebits.wiki.api.post() are invoked asynchronously from the jQuery AJAX library.
 * 2. The sequence for append/prepend/newSection could be slightly shortened,
 * but it would require significant duplication of code for little benefit.
 *
 *
 * @memberof Morebits.wiki
 * @class
 * @param {string} pageName - The name of the page, prefixed by the namespace (if any).
 * For the current page, use &#x60;mw.config.get(&#x27;wgPageName&#x27;)&#x60;.
 * @param {string|Morebits.status} [status] - A string describing the action about to be undertaken,
 * or a Morebits.status object
 */
Morebits.wiki.page &#x3D; function(pageName, status) {

	if (!status) {
		status &#x3D; &#x27;Opening page &quot;&#x27; + pageName + &#x27;&quot;&#x27;;
	}

	/**
	 * Private context variables.
	 *
	 * This context is not visible to the outside, thus all the data here
	 * must be accessed via getter and setter functions.
	 *
	 * @private
	 */
	var ctx &#x3D; {
		// backing fields for public properties
		pageName: pageName,
		pageExists: false,
		editSummary: null,
		changeTags: null,
		testActions: null,  // array if any valid actions
		callbackParameters: null,
		statusElement: status instanceof Morebits.status ? status : new Morebits.status(status),

		// - edit
		pageText: null,
		editMode: &#x27;all&#x27;,  // save() replaces entire contents of the page by default
		appendText: null,   // can&#x27;t reuse pageText for this because pageText is needed to follow a redirect
		prependText: null,  // can&#x27;t reuse pageText for this because pageText is needed to follow a redirect
		newSectionText: null,
		newSectionTitle: null,
		createOption: null,
		minorEdit: false,
		botEdit: false,
		pageSection: null,
		maxConflictRetries: 2,
		maxRetries: 2,
		followRedirect: false,
		followCrossNsRedirect: true,
		watchlistOption: &#x27;nochange&#x27;,
		watchlistExpiry: null,
		creator: null,
		timestamp: null,

		// - revert
		revertOldID: null,

		// - move
		moveDestination: null,
		moveTalkPage: false,
		moveSubpages: false,
		moveSuppressRedirect: false,

		// - protect
		protectEdit: null,
		protectMove: null,
		protectCreate: null,
		protectCascade: null,

		// - creation lookup
		lookupNonRedirectCreator: false,

		// - stabilize (FlaggedRevs)
		flaggedRevs: null,

		// internal status
		pageLoaded: false,
		csrfToken: null,
		loadTime: null,
		lastEditTime: null,
		pageID: null,
		contentModel: null,
		revertCurID: null,
		revertUser: null,
		watched: false,
		fullyProtected: false,
		suppressProtectWarning: false,
		conflictRetries: 0,
		retries: 0,

		// callbacks
		onLoadSuccess: null,
		onLoadFailure: null,
		onSaveSuccess: null,
		onSaveFailure: null,
		onLookupCreationSuccess: null,
		onMoveSuccess: null,
		onMoveFailure: null,
		onDeleteSuccess: null,
		onDeleteFailure: null,
		onUndeleteSuccess: null,
		onUndeleteFailure: null,
		onProtectSuccess: null,
		onProtectFailure: null,
		onStabilizeSuccess: null,
		onStabilizeFailure: null,

		// internal objects
		loadQuery: null,
		loadApi: null,
		saveApi: null,
		lookupCreationApi: null,
		moveApi: null,
		moveProcessApi: null,
		patrolApi: null,
		patrolProcessApi: null,
		triageApi: null,
		triageProcessListApi: null,
		triageProcessApi: null,
		deleteApi: null,
		deleteProcessApi: null,
		undeleteApi: null,
		undeleteProcessApi: null,
		protectApi: null,
		protectProcessApi: null,
		stabilizeApi: null,
		stabilizeProcessApi: null
	};

	var emptyFunction &#x3D; function() { };

	/**
	 * Loads the text for the page.
	 *
	 * @param {Function} onSuccess - Callback function which is called when the load has succeeded.
	 * @param {Function} [onFailure] - Callback function which is called when the load fails.
	 */
	this.load &#x3D; function(onSuccess, onFailure) {
		ctx.onLoadSuccess &#x3D; onSuccess;
		ctx.onLoadFailure &#x3D; onFailure || emptyFunction;

		// Need to be able to do something after the page loads
		if (!onSuccess) {
			ctx.statusElement.error(&#x27;Internal error: no onSuccess callback provided to load()!&#x27;);
			ctx.onLoadFailure(this);
			return;
		}

		ctx.loadQuery &#x3D; {
			action: &#x27;query&#x27;,
			prop: &#x27;info|revisions&#x27;,
			inprop: &#x27;watched&#x27;,
			intestactions: &#x27;edit&#x27;, // can be expanded
			curtimestamp: &#x27;&#x27;,
			meta: &#x27;tokens&#x27;,
			type: &#x27;csrf&#x27;,
			titles: ctx.pageName,
			format: &#x27;json&#x27;
			// don&#x27;t need rvlimit&#x3D;1 because we don&#x27;t need rvstartid here and only one actual rev is returned by default
		};

		if (ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;all&#x27;) {
			ctx.loadQuery.rvprop &#x3D; &#x27;content|timestamp&#x27;;  // get the page content at the same time, if needed
		} else if (ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;revert&#x27;) {
			ctx.loadQuery.rvprop &#x3D; &#x27;timestamp&#x27;;
			ctx.loadQuery.rvlimit &#x3D; 1;
			ctx.loadQuery.rvstartid &#x3D; ctx.revertOldID;
		}

		if (ctx.followRedirect) {
			ctx.loadQuery.redirects &#x3D; &#x27;&#x27;;  // follow all redirects
		}
		if (typeof ctx.pageSection &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
			ctx.loadQuery.rvsection &#x3D; ctx.pageSection;
		}
		if (Morebits.userIsSysop) {
			ctx.loadQuery.inprop +&#x3D; &#x27;|protection&#x27;;
		}

		ctx.loadApi &#x3D; new Morebits.wiki.api(&#x27;Retrieving page...&#x27;, ctx.loadQuery, fnLoadSuccess, ctx.statusElement, ctx.onLoadFailure);
		ctx.loadApi.setParent(this);
		ctx.loadApi.post();
	};

	/**
	 * Saves the text for the page to Wikipedia.
	 * Must be preceded by successfully calling &#x60;load()&#x60;.
	 *
	 * Warning: Calling &#x60;save()&#x60; can result in additional calls to the
	 * previous &#x60;load()&#x60; callbacks to recover from edit conflicts! In this
	 * case, callers must make the same edit to the new pageText and
	 * reinvoke &#x60;save()&#x60;.  This behavior can be disabled with
	 * &#x60;setMaxConflictRetries(0)&#x60;.
	 *
	 * @param {Function} [onSuccess] - Callback function which is called when the save has succeeded.
	 * @param {Function} [onFailure] - Callback function which is called when the save fails.
	 */
	this.save &#x3D; function(onSuccess, onFailure) {
		ctx.onSaveSuccess &#x3D; onSuccess;
		ctx.onSaveFailure &#x3D; onFailure || emptyFunction;

		// are we getting our editing token from mw.user.tokens?
		var canUseMwUserToken &#x3D; fnCanUseMwUserToken(&#x27;edit&#x27;);

		if (!ctx.pageLoaded &amp;amp;&amp;amp; !canUseMwUserToken) {
			ctx.statusElement.error(&#x27;Internal error: attempt to save a page that has not been loaded!&#x27;);
			ctx.onSaveFailure(this);
			return;
		}
		if (!ctx.editSummary) {
			// new section mode allows (nay, encourages) using the
			// title as the edit summary, but the query needs
			// editSummary to be undefined or &#x27;&#x27;, not null
			if (ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;new&#x27; &amp;amp;&amp;amp; ctx.newSectionTitle) {
				ctx.editSummary &#x3D; &#x27;&#x27;;
			} else {
				ctx.statusElement.error(&#x27;Internal error: edit summary not set before save!&#x27;);
				ctx.onSaveFailure(this);
				return;
			}
		}

		// shouldn&#x27;t happen if canUseMwUserToken &#x3D;&#x3D;&#x3D; true
		if (ctx.fullyProtected &amp;amp;&amp;amp; !ctx.suppressProtectWarning &amp;amp;&amp;amp;
			!confirm(&#x27;You are about to make an edit to the fully protected page &quot;&#x27; + ctx.pageName +
			(ctx.fullyProtected &#x3D;&#x3D;&#x3D; &#x27;infinity&#x27; ? &#x27;&quot; (protected indefinitely)&#x27; : &#x27;&quot; (protection expiring &#x27; + new Morebits.date(ctx.fullyProtected).calendar(&#x27;utc&#x27;) + &#x27; (UTC))&#x27;) +
			&#x27;.  \n\nClick OK to proceed with the edit, or Cancel to skip this edit.&#x27;)) {
			ctx.statusElement.error(&#x27;Edit to fully protected page was aborted.&#x27;);
			ctx.onSaveFailure(this);
			return;
		}

		ctx.retries &#x3D; 0;

		var query &#x3D; {
			action: &#x27;edit&#x27;,
			title: ctx.pageName,
			summary: ctx.editSummary,
			token: canUseMwUserToken ? mw.user.tokens.get(&#x27;csrfToken&#x27;) : ctx.csrfToken,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}

		if (typeof ctx.pageSection &#x3D;&#x3D;&#x3D; &#x27;number&#x27;) {
			query.section &#x3D; ctx.pageSection;
		}

		// Set minor edit attribute. If these parameters are present with any value, it is interpreted as true
		if (ctx.minorEdit) {
			query.minor &#x3D; true;
		} else {
			query.notminor &#x3D; true;  // force Twinkle config to override user preference setting for &quot;all edits are minor&quot;
		}

		// Set bot edit attribute. If this paramter is present with any value, it is interpreted as true
		if (ctx.botEdit) {
			query.bot &#x3D; true;
		}

		switch (ctx.editMode) {
			case &#x27;append&#x27;:
				if (ctx.appendText &#x3D;&#x3D;&#x3D; null) {
					ctx.statusElement.error(&#x27;Internal error: append text not set before save!&#x27;);
					ctx.onSaveFailure(this);
					return;
				}
				query.appendtext &#x3D; ctx.appendText;  // use mode to append to current page contents
				break;
			case &#x27;prepend&#x27;:
				if (ctx.prependText &#x3D;&#x3D;&#x3D; null) {
					ctx.statusElement.error(&#x27;Internal error: prepend text not set before save!&#x27;);
					ctx.onSaveFailure(this);
					return;
				}
				query.prependtext &#x3D; ctx.prependText;  // use mode to prepend to current page contents
				break;
			case &#x27;new&#x27;:
				if (!ctx.newSectionText) { // API doesn&#x27;t allow empty new section text
					ctx.statusElement.error(&#x27;Internal error: new section text not set before save!&#x27;);
					ctx.onSaveFailure(this);
					return;
				}
				query.section &#x3D; &#x27;new&#x27;;
				query.text &#x3D; ctx.newSectionText;  // add a new section to current page
				query.sectiontitle &#x3D; ctx.newSectionTitle || ctx.editSummary; // done by the API, but non-&#x27;&#x27; values would get treated as text
				break;
			case &#x27;revert&#x27;:
				query.undo &#x3D; ctx.revertCurID;
				query.undoafter &#x3D; ctx.revertOldID;
				if (ctx.lastEditTime) {
					query.basetimestamp &#x3D; ctx.lastEditTime; // check that page hasn&#x27;t been edited since it was loaded
				}
				query.starttimestamp &#x3D; ctx.loadTime; // check that page hasn&#x27;t been deleted since it was loaded (don&#x27;t recreate bad stuff)
				break;
			default: // &#x27;all&#x27;
				query.text &#x3D; ctx.pageText; // replace entire contents of the page
				if (ctx.lastEditTime) {
					query.basetimestamp &#x3D; ctx.lastEditTime; // check that page hasn&#x27;t been edited since it was loaded
				}
				query.starttimestamp &#x3D; ctx.loadTime; // check that page hasn&#x27;t been deleted since it was loaded (don&#x27;t recreate bad stuff)
				break;
		}

		if ([&#x27;recreate&#x27;, &#x27;createonly&#x27;, &#x27;nocreate&#x27;].indexOf(ctx.createOption) !&#x3D;&#x3D; -1) {
			query[ctx.createOption] &#x3D; &#x27;&#x27;;
		}

		if (canUseMwUserToken &amp;amp;&amp;amp; ctx.followRedirect) {
			query.redirect &#x3D; true;
		}

		ctx.saveApi &#x3D; new Morebits.wiki.api(&#x27;Saving page...&#x27;, query, fnSaveSuccess, ctx.statusElement, fnSaveError);
		ctx.saveApi.setParent(this);
		ctx.saveApi.post();
	};

	/**
	 * Adds the text provided via &#x60;setAppendText()&#x60; to the end of the
	 * page.  Does not require calling &#x60;load()&#x60; first, unless a watchlist
	 * expiry is used.
	 *
	 * @param {Function} [onSuccess] - Callback function which is called when the method has succeeded.
	 * @param {Function} [onFailure] - Callback function which is called when the method fails.
	 */
	this.append &#x3D; function(onSuccess, onFailure) {
		ctx.editMode &#x3D; &#x27;append&#x27;;

		if (fnCanUseMwUserToken(&#x27;edit&#x27;)) {
			this.save(onSuccess, onFailure);
		} else {
			ctx.onSaveSuccess &#x3D; onSuccess;
			ctx.onSaveFailure &#x3D; onFailure || emptyFunction;
			this.load(fnAutoSave, ctx.onSaveFailure);
		}
	};

	/**
	 * Adds the text provided via &#x60;setPrependText()&#x60; to the start of the
	 * page.  Does not require calling &#x60;load()&#x60; first, unless a watchlist
	 * expiry is used.
	 *
	 * @param {Function}  [onSuccess] - Callback function which is called when the method has succeeded.
	 * @param {Function}  [onFailure] - Callback function which is called when the method fails.
	 */
	this.prepend &#x3D; function(onSuccess, onFailure) {
		ctx.editMode &#x3D; &#x27;prepend&#x27;;

		if (fnCanUseMwUserToken(&#x27;edit&#x27;)) {
			this.save(onSuccess, onFailure);
		} else {
			ctx.onSaveSuccess &#x3D; onSuccess;
			ctx.onSaveFailure &#x3D; onFailure || emptyFunction;
			this.load(fnAutoSave, ctx.onSaveFailure);
		}
	};

	/**
	 * Creates a new section with the text provided by &#x60;setNewSectionText()&#x60;
	 * and section title from &#x60;setNewSectionTitle()&#x60;.
	 * If &#x60;editSummary&#x60; is provided, that will be used instead of the
	 * autogenerated &quot;-&gt;Title (new section&quot; edit summary.
	 * Does not require calling &#x60;load()&#x60; first, unless a watchlist expiry
	 * is used.
	 *
	 * @param {Function}  [onSuccess] - Callback function which is called when the method has succeeded.
	 * @param {Function}  [onFailure] - Callback function which is called when the method fails.
	 */
	this.newSection &#x3D; function(onSuccess, onFailure) {
		ctx.editMode &#x3D; &#x27;new&#x27;;

		if (fnCanUseMwUserToken(&#x27;edit&#x27;)) {
			this.save(onSuccess, onFailure);
		} else {
			ctx.onSaveSuccess &#x3D; onSuccess;
			ctx.onSaveFailure &#x3D; onFailure || emptyFunction;
			this.load(fnAutoSave, ctx.onSaveFailure);
		}
	};

	/** @returns {string} The name of the loaded page, including the namespace */
	this.getPageName &#x3D; function() {
		return ctx.pageName;
	};

	/** @returns {string} The text of the page after a successful load() */
	this.getPageText &#x3D; function() {
		return ctx.pageText;
	};

	/** @param {string} pageText - Updated page text that will be saved when &#x60;save()&#x60; is called */
	this.setPageText &#x3D; function(pageText) {
		ctx.editMode &#x3D; &#x27;all&#x27;;
		ctx.pageText &#x3D; pageText;
	};

	/** @param {string} appendText - Text that will be appended to the page when &#x60;append()&#x60; is called */
	this.setAppendText &#x3D; function(appendText) {
		ctx.editMode &#x3D; &#x27;append&#x27;;
		ctx.appendText &#x3D; appendText;
	};

	/** @param {string} prependText - Text that will be prepended to the page when &#x60;prepend()&#x60; is called */
	this.setPrependText &#x3D; function(prependText) {
		ctx.editMode &#x3D; &#x27;prepend&#x27;;
		ctx.prependText &#x3D; prependText;
	};

	/** @param {string} newSectionText - Text that will be added in a new section on the page when &#x60;newSection()&#x60; is called */
	this.setNewSectionText &#x3D; function(newSectionText) {
		ctx.editMode &#x3D; &#x27;new&#x27;;
		ctx.newSectionText &#x3D; newSectionText;
	};

	/**
	 * @param {string} newSectionTitle - Title for the new section created when &#x60;newSection()&#x60; is called
	 * If missing, &#x60;ctx.editSummary&#x60; will be used. Issues may occur if a substituted template is used.
	 */
	this.setNewSectionTitle &#x3D; function(newSectionTitle) {
		ctx.editMode &#x3D; &#x27;new&#x27;;
		ctx.newSectionTitle &#x3D; newSectionTitle;
	};



	// Edit-related setter methods:
	/**
	 * Set the edit summary that will be used when &#x60;save()&#x60; is called.
	 * Unnecessary if editMode is &#x27;new&#x27; and newSectionTitle is provided.
	 *
	 * @param {string} summary
	 */
	this.setEditSummary &#x3D; function(summary) {
		ctx.editSummary &#x3D; summary;
	};

	/**
	 * Set any custom tag(s) to be applied to the API action.
	 * A number of actions don&#x27;t support it, most notably watch, review,
	 * and stabilize ({@link https://phabricator.wikimedia.org/T247721|T247721}), and
	 * pagetriageaction ({@link https://phabricator.wikimedia.org/T252980|T252980}).
	 *
	 * @param {string|string[]} tags - String or array of tag(s).
	 */
	this.setChangeTags &#x3D; function(tags) {
		ctx.changeTags &#x3D; tags;
	};


	/**
	 * @param {string} [createOption&#x3D;null] - Can take the following four values:
	 * - recreate: create the page if it does not exist, or edit it if it exists.
	 * - createonly: create the page if it does not exist, but return an
	 * error if it already exists.
	 * - nocreate: don&#x27;t create the page, only edit it if it already exists.
	 * - &#x60;null&#x60;: create the page if it does not exist, unless it was deleted
	 * in the moment between loading the page and saving the edit (default).
	 *
	 */
	this.setCreateOption &#x3D; function(createOption) {
		ctx.createOption &#x3D; createOption;
	};

	/** @param {boolean} minorEdit - Set true to mark the edit as a minor edit. */
	this.setMinorEdit &#x3D; function(minorEdit) {
		ctx.minorEdit &#x3D; minorEdit;
	};

	/** @param {boolean} botEdit - Set true to mark the edit as a bot edit */
	this.setBotEdit &#x3D; function(botEdit) {
		ctx.botEdit &#x3D; botEdit;
	};

	/**
	 * @param {number} pageSection - Integer specifying the section number to load or save.
	 * If specified as &#x60;null&#x60;, the entire page will be retrieved.
	 */
	this.setPageSection &#x3D; function(pageSection) {
		ctx.pageSection &#x3D; pageSection;
	};

	/**
	 * @param {number} maxConflictRetries - Number of retries for save errors involving an edit conflict or
	 * loss of token. Default: 2.
	 */
	this.setMaxConflictRetries &#x3D; function(maxConflictRetries) {
		ctx.maxConflictRetries &#x3D; maxConflictRetries;
	};

	/**
	 * @param {number} maxRetries - Number of retries for save errors not involving an edit conflict or
	 * loss of token. Default: 2.
	 */
	this.setMaxRetries &#x3D; function(maxRetries) {
		ctx.maxRetries &#x3D; maxRetries;
	};

	/**
	 * @param {boolean|string} [watchlistOption&#x3D;false] -
	 * Basically a mix of MW API and Twinkley options available pre-expiry:
	 * - &#x60;true&#x60;|&#x60;&#x27;yes&#x27;&#x60;: page will be added to the user&#x27;s watchlist when the action is called
	 * - &#x60;false&#x60;|&#x60;&#x27;no&#x27;&#x60;|&#x60;&#x27;nochange&#x27;&#x60;: watchlist status of the page will not be changed.
	 * - &#x60;&#x27;default&#x27;&#x60;|&#x60;&#x27;preferences&#x27;&#x60;: watchlist status of the page will
	 * be set based on the user&#x27;s preference settings when the action is
	 * called.  Ignores ability of default + expiry.
	 * - &#x60;&#x27;unwatch&#x27;&#x60;: explicitly unwatch the page
	 * - {string|number}: watch page until the specified time (relative or absolute datestring)
	 */
	this.setWatchlist &#x3D; function(watchlistOption) {
		if (!watchlistOption || watchlistOption &#x3D;&#x3D;&#x3D; &#x27;no&#x27; || watchlistOption &#x3D;&#x3D;&#x3D; &#x27;nochange&#x27;) {
			ctx.watchlistOption &#x3D; &#x27;nochange&#x27;;
		} else if (watchlistOption &#x3D;&#x3D;&#x3D; &#x27;default&#x27; || watchlistOption &#x3D;&#x3D;&#x3D; &#x27;preferences&#x27;) {
			ctx.watchlistOption &#x3D; &#x27;preferences&#x27;;
		} else if (watchlistOption &#x3D;&#x3D;&#x3D; &#x27;unwatch&#x27;) {
			ctx.watchlistOption &#x3D; &#x27;unwatch&#x27;;
		} else {
			ctx.watchlistOption &#x3D; &#x27;watch&#x27;;
			if (typeof watchlistOption &#x3D;&#x3D;&#x3D; &#x27;number&#x27; || (typeof watchlistOption &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;amp;&amp;amp; watchlistOption !&#x3D;&#x3D; &#x27;yes&#x27;)) {
				ctx.watchlistExpiry &#x3D; watchlistOption;
			}
		}
	};

	/**
	 * Set an expiry. setWatchlist can handle this by itself if passed a
	 * string, so this is here largely for completeness and compatibility.
	 *
	 * @param {string} watchlistExpiry - A date-like string or array of strings
	 * Can be relative (2 weeks) or other similarly date-like (i.e. NOT &quot;potato&quot;):
	 * ISO 8601: 2038-01-09T03:14:07Z
	 * MediaWiki: 20380109031407
	 * UNIX: 2147483647
	 * SQL: 2038-01-09 03:14:07
	 * Can also be &#x60;infinity&#x60; or infinity-like (&#x60;infinite&#x60;, &#x60;indefinite&#x60;, and &#x60;never&#x60;).
	 * See {@link https://phabricator.wikimedia.org/source/mediawiki-libs-Timestamp/browse/master/src/ConvertibleTimestamp.php;4e53b859a9580c55958078f46dd4f3a44d0fcaa0$57-109?as&#x3D;source&amp;amp;blame&#x3D;off}
	 */
	this.setWatchlistExpiry &#x3D; function(watchlistExpiry) {
		ctx.watchlistExpiry &#x3D; watchlistExpiry;
	};

	/**
	 * @deprecated As of December 2020, use setWatchlist.
	 * @param {boolean} [watchlistOption&#x3D;false] -
	 * - &#x60;True&#x60;: page watchlist status will be set based on the user&#x27;s
	 * preference settings when &#x60;save()&#x60; is called.
	 * - &#x60;False&#x60;: watchlist status of the page will not be changed.
	 *
	 * Watchlist notes:
	 * 1. The MediaWiki API value of &#x27;unwatch&#x27;, which explicitly removes
	 * the page from the user&#x27;s watchlist, is not used.
	 * 2. If both &#x60;setWatchlist()&#x60; and &#x60;setWatchlistFromPreferences()&#x60; are
	 * called, the last call takes priority.
	 * 3. Twinkle modules should use the appropriate preference to set the watchlist options.
	 * 4. Most Twinkle modules use &#x60;setWatchlist()&#x60;. &#x60;setWatchlistFromPreferences()&#x60;
	 * is only needed for the few Twinkle watchlist preferences that
	 * accept a string value of &#x60;default&#x60;.
	 */
	this.setWatchlistFromPreferences &#x3D; function(watchlistOption) {
		console.warn(&#x27;NOTE: Morebits.wiki.page.setWatchlistFromPreferences was deprecated December 2020, please use setWatchlist&#x27;); // eslint-disable-line no-console
		if (watchlistOption) {
			ctx.watchlistOption &#x3D; &#x27;preferences&#x27;;
		} else {
			ctx.watchlistOption &#x3D; &#x27;nochange&#x27;;
		}
	};

	/**
	 * @param {boolean} [followRedirect&#x3D;false] -
	 * - &#x60;true&#x60;: a maximum of one redirect will be followed. In the event
	 * of a redirect, a message is displayed to the user and the redirect
	 * target can be retrieved with getPageName().
	 * - &#x60;false&#x60;: (default) the requested pageName will be used without regard to any redirect.
	 * @param {boolean} [followCrossNsRedirect&#x3D;true] - Not applicable if &#x60;followRedirect&#x60; is not set true.
	 * - &#x60;true&#x60;: (default) follow redirect even if it is a cross-namespace redirect
	 * - &#x60;false&#x60;: don&#x27;t follow redirect if it is cross-namespace, edit the redirect itself.
	 */
	this.setFollowRedirect &#x3D; function(followRedirect, followCrossNsRedirect) {
		if (ctx.pageLoaded) {
			ctx.statusElement.error(&#x27;Internal error: cannot change redirect setting after the page has been loaded!&#x27;);
			return;
		}
		ctx.followRedirect &#x3D; followRedirect;
		ctx.followCrossNsRedirect &#x3D; typeof followCrossNsRedirect !&#x3D;&#x3D; &#x27;undefined&#x27; ? followCrossNsRedirect : ctx.followCrossNsRedirect;
	};

	// lookup-creation setter function
	/**
	 * @param {boolean} flag - If set true, the author and timestamp of
	 * the first non-redirect version of the page is retrieved.
	 *
	 * Warning:
	 * 1. If there are no revisions among the first 50 that are
	 * non-redirects, or if there are less 50 revisions and all are
	 * redirects, the original creation is retrived.
	 * 2. Revisions that the user is not privileged to access
	 * (revdeled/suppressed) will be treated as non-redirects.
	 * 3. Must not be used when the page has a non-wikitext contentmodel
	 * such as Modulespace Lua or user JavaScript/CSS.
	 */
	this.setLookupNonRedirectCreator &#x3D; function(flag) {
		ctx.lookupNonRedirectCreator &#x3D; flag;
	};

	// Move-related setter functions
	/** @param {string} destination */
	this.setMoveDestination &#x3D; function(destination) {
		ctx.moveDestination &#x3D; destination;
	};

	/** @param {boolean} flag */
	this.setMoveTalkPage &#x3D; function(flag) {
		ctx.moveTalkPage &#x3D; !!flag;
	};

	/** @param {boolean} flag */
	this.setMoveSubpages &#x3D; function(flag) {
		ctx.moveSubpages &#x3D; !!flag;
	};

	/** @param {boolean} flag */
	this.setMoveSuppressRedirect &#x3D; function(flag) {
		ctx.moveSuppressRedirect &#x3D; !!flag;
	};

	// Protect-related setter functions
	/**
	 * @param {string} level - The right required for the specific action
	 * e.g. autoconfirmed, sysop, templateeditor, extendedconfirmed
	 * (enWiki-only).
	 * @param {string} [expiry&#x3D;infinity]
	 */
	this.setEditProtection &#x3D; function(level, expiry) {
		ctx.protectEdit &#x3D; { level: level, expiry: expiry || &#x27;infinity&#x27; };
	};

	this.setMoveProtection &#x3D; function(level, expiry) {
		ctx.protectMove &#x3D; { level: level, expiry: expiry || &#x27;infinity&#x27; };
	};

	this.setCreateProtection &#x3D; function(level, expiry) {
		ctx.protectCreate &#x3D; { level: level, expiry: expiry || &#x27;infinity&#x27; };
	};

	this.setCascadingProtection &#x3D; function(flag) {
		ctx.protectCascade &#x3D; !!flag;
	};

	this.suppressProtectWarning &#x3D; function() {
		ctx.suppressProtectWarning &#x3D; true;
	};

	// Revert-related getters/setters:
	this.setOldID &#x3D; function(oldID) {
		ctx.revertOldID &#x3D; oldID;
	};

	/** @returns {string} The current revision ID of the page */
	this.getCurrentID &#x3D; function() {
		return ctx.revertCurID;
	};

	/** @returns {string} Last editor of the page */
	this.getRevisionUser &#x3D; function() {
		return ctx.revertUser;
	};

	/** @returns {string} ISO 8601 timestamp at which the page was last edited. */
	this.getLastEditTime &#x3D; function() {
		return ctx.lastEditTime;
	};

	// Miscellaneous getters/setters:

	/**
	 * Define an object for use in a callback function.
	 *
	 * &#x60;callbackParameters&#x60; is for use by the caller only. The parameters
	 * allow a caller to pass the proper context into its callback
	 * function.  Callers must ensure that any changes to the
	 * callbackParameters object within a &#x60;load()&#x60; callback still permit a
	 * proper re-entry into the &#x60;load()&#x60; callback if an edit conflict is
	 * detected upon calling &#x60;save()&#x60;.
	 *
	 * @param {object} callbackParameters
	 */
	this.setCallbackParameters &#x3D; function(callbackParameters) {
		ctx.callbackParameters &#x3D; callbackParameters;
	};

	/**
	 * @returns {object} - The object previously set by &#x60;setCallbackParameters()&#x60;.
	 */
	this.getCallbackParameters &#x3D; function() {
		return ctx.callbackParameters;
	};

	/**
	 * @param {Morebits.status} statusElement
	 */
	this.setStatusElement &#x3D; function(statusElement) {
		ctx.statusElement &#x3D; statusElement;
	};

	/**
	 * @returns {Morebits.status} Status element created by the constructor.
	 */
	this.getStatusElement &#x3D; function() {
		return ctx.statusElement;
	};

	/**
	 * @param {string} level - The right required for edits not to require
	 * review. Possible options: none, autoconfirmed, review (not on enWiki).
	 * @param {string} [expiry&#x3D;infinity]
	 */
	this.setFlaggedRevs &#x3D; function(level, expiry) {
		ctx.flaggedRevs &#x3D; { level: level, expiry: expiry || &#x27;infinity&#x27; };
	};

	/**
	 * @returns {boolean} True if the page existed on the wiki when it was last loaded.
	 */
	this.exists &#x3D; function() {
		return ctx.pageExists;
	};

	/**
	 * @returns {string} Page ID of the page loaded. 0 if the page doesn&#x27;t
	 * exist.
	 */
	this.getPageID &#x3D; function() {
		return ctx.pageID;
	};

	/**
	 * @returns {string} - Content model of the page.  Possible values
	 * include (but may not be limited to): &#x60;wikitext&#x60;, &#x60;javascript&#x60;,
	 * &#x60;css&#x60;, &#x60;json&#x60;, &#x60;Scribunto&#x60;, &#x60;sanitized-css&#x60;, &#x60;MassMessageListContent&#x60;.
	 * Also gettable via &#x60;mw.config.get(&#x27;wgPageContentModel&#x27;)&#x60;.
	 */
	this.getContentModel &#x3D; function() {
		return ctx.contentModel;
	};

	/**
	 * @returns {boolean|string} - Watched status of the page. Boolean
	 * unless it&#x27;s being watched temporarily, in which case returns the
	 * expiry string.
	 */
	this.getWatched &#x3D; function () {
		return ctx.watched;
	};

	/**
	 * @returns {string} ISO 8601 timestamp at which the page was last loaded.
	 */
	this.getLoadTime &#x3D; function() {
		return ctx.loadTime;
	};

	/**
	 * @returns {string} The user who created the page following &#x60;lookupCreation()&#x60;.
	 */
	this.getCreator &#x3D; function() {
		return ctx.creator;
	};

	/**
	 * @returns {string} The ISOString timestamp of page creation following &#x60;lookupCreation()&#x60;.
	 */
	this.getCreationTimestamp &#x3D; function() {
		return ctx.timestamp;
	};

	/** @returns {boolean} whether or not you can edit the page */
	this.canEdit &#x3D; function() {
		return !!ctx.testActions &amp;amp;&amp;amp; ctx.testActions.indexOf(&#x27;edit&#x27;) !&#x3D;&#x3D; -1;
	};

	/**
	 * Retrieves the username of the user who created the page as well as
	 * the timestamp of creation.  The username can be retrieved using the
	 * &#x60;getCreator()&#x60; function; the timestamp can be retrieved using the
	 * &#x60;getCreationTimestamp()&#x60; function.
	 * Prior to June 2019 known as &#x60;lookupCreator()&#x60;.
	 *
	 * @param {Function} onSuccess - Callback function to be called when
	 * the username and timestamp are found within the callback.
	 */
	this.lookupCreation &#x3D; function(onSuccess) {
		if (!onSuccess) {
			ctx.statusElement.error(&#x27;Internal error: no onSuccess callback provided to lookupCreation()!&#x27;);
			return;
		}
		ctx.onLookupCreationSuccess &#x3D; onSuccess;

		var query &#x3D; {
			action: &#x27;query&#x27;,
			prop: &#x27;revisions&#x27;,
			titles: ctx.pageName,
			rvlimit: 1,
			rvprop: &#x27;user|timestamp&#x27;,
			rvdir: &#x27;newer&#x27;,
			format: &#x27;json&#x27;
		};

		// Only the wikitext content model can reliably handle
		// rvsection, others return an error when paired with the
		// content rvprop. Relatedly, non-wikitext models don&#x27;t
		// understand the #REDIRECT concept, so we shouldn&#x27;t attempt
		// the redirect resolution in fnLookupCreationSuccess
		if (ctx.lookupNonRedirectCreator) {
			query.rvsection &#x3D; 0;
			query.rvprop +&#x3D; &#x27;|content&#x27;;
		}

		if (ctx.followRedirect) {
			query.redirects &#x3D; &#x27;&#x27;;  // follow all redirects
		}

		ctx.lookupCreationApi &#x3D; new Morebits.wiki.api(&#x27;Retrieving page creation information&#x27;, query, fnLookupCreationSuccess, ctx.statusElement);
		ctx.lookupCreationApi.setParent(this);
		ctx.lookupCreationApi.post();
	};

	/**
	 * Reverts a page to &#x60;revertOldID&#x60; set by &#x60;setOldID&#x60;.
	 *
	 * @param {Function} [onSuccess] - Callback function to run on success.
	 * @param {Function} [onFailure] - Callback function to run on failure.
	 */
	this.revert &#x3D; function(onSuccess, onFailure) {
		ctx.onSaveSuccess &#x3D; onSuccess;
		ctx.onSaveFailure &#x3D; onFailure || emptyFunction;

		if (!ctx.revertOldID) {
			ctx.statusElement.error(&#x27;Internal error: revision ID to revert to was not set before revert!&#x27;);
			ctx.onSaveFailure(this);
			return;
		}

		ctx.editMode &#x3D; &#x27;revert&#x27;;
		this.load(fnAutoSave, ctx.onSaveFailure);
	};

	/**
	 * Moves a page to another title.
	 *
	 * @param {Function} [onSuccess] - Callback function to run on success.
	 * @param {Function} [onFailure] - Callback function to run on failure.
	 */
	this.move &#x3D; function(onSuccess, onFailure) {
		ctx.onMoveSuccess &#x3D; onSuccess;
		ctx.onMoveFailure &#x3D; onFailure || emptyFunction;

		if (!fnPreflightChecks.call(this, &#x27;move&#x27;, ctx.onMoveFailure)) {
			return; // abort
		}

		if (!ctx.moveDestination) {
			ctx.statusElement.error(&#x27;Internal error: destination page name was not set before move!&#x27;);
			ctx.onMoveFailure(this);
			return;
		}

		if (fnCanUseMwUserToken(&#x27;move&#x27;)) {
			fnProcessMove.call(this, this);
		} else {
			var query &#x3D; fnNeedTokenInfoQuery(&#x27;move&#x27;);

			ctx.moveApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessMove, ctx.statusElement, ctx.onMoveFailure);
			ctx.moveApi.setParent(this);
			ctx.moveApi.post();
		}
	};

	/**
	 * Marks the page as patrolled, using &#x60;rcid&#x60; (if available) or &#x60;revid&#x60;.
	 *
	 * Patrolling as such doesn&#x27;t need to rely on loading the page in
	 * question; simply passing a revid to the API is sufficient, so in
	 * those cases just using {@link Morebits.wiki.api} is probably preferable.
	 *
	 * No error handling since we don&#x27;t actually care about the errors.
	 */
	this.patrol &#x3D; function() {
		if (!Morebits.userIsSysop &amp;amp;&amp;amp; !Morebits.userIsInGroup(&#x27;patroller&#x27;)) {
			return;
		}

		// If a link is present, don&#x27;t need to check if it&#x27;s patrolled
		if ($(&#x27;.patrollink&#x27;).length) {
			var patrolhref &#x3D; $(&#x27;.patrollink a&#x27;).attr(&#x27;href&#x27;);
			ctx.rcid &#x3D; mw.util.getParamValue(&#x27;rcid&#x27;, patrolhref);
			fnProcessPatrol(this, this);
		} else {
			var patrolQuery &#x3D; {
				action: &#x27;query&#x27;,
				prop: &#x27;info&#x27;,
				meta: &#x27;tokens&#x27;,
				type: &#x27;patrol&#x27;, // as long as we&#x27;re querying, might as well get a token
				list: &#x27;recentchanges&#x27;, // check if the page is unpatrolled
				titles: ctx.pageName,
				rcprop: &#x27;patrolled&#x27;,
				rctitle: ctx.pageName,
				rclimit: 1,
				format: &#x27;json&#x27;
			};

			ctx.patrolApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, patrolQuery, fnProcessPatrol);
			ctx.patrolApi.setParent(this);
			ctx.patrolApi.post();
		}
	};

	/**
	 * Marks the page as reviewed by the PageTriage extension.
	 *
	 * Will, by it&#x27;s nature, mark as patrolled as well. Falls back to
	 * patrolling if not in an appropriate namespace.
	 *
	 * Doesn&#x27;t inherently rely on loading the page in question; simply
	 * passing a &#x60;pageid&#x60; to the API is sufficient, so in those cases just
	 * using {@link Morebits.wiki.api} is probably preferable.
	 *
	 * Will first check if the page is queued via
	 * {@link Morebits.wiki.page~fnProcessTriageList|fnProcessTriageList}.
	 *
	 * No error handling since we don&#x27;t actually care about the errors.
	 *
	 * @see {@link https://www.mediawiki.org/wiki/Extension:PageTriage} Referred to as &quot;review&quot; on-wiki.
	 */
	this.triage &#x3D; function() {
		// Fall back to patrol if not a valid triage namespace
		if (mw.config.get(&#x27;pageTriageNamespaces&#x27;).indexOf(new mw.Title(ctx.pageName).getNamespaceId()) &#x3D;&#x3D;&#x3D; -1) {
			this.patrol();
		} else {
			if (!Morebits.userIsSysop &amp;amp;&amp;amp; !Morebits.userIsInGroup(&#x27;patroller&#x27;)) {
				return;
			}

			// If on the page in question, don&#x27;t need to query for page ID
			if (new mw.Title(Morebits.pageNameNorm).getPrefixedText() &#x3D;&#x3D;&#x3D; new mw.Title(ctx.pageName).getPrefixedText()) {
				ctx.pageID &#x3D; mw.config.get(&#x27;wgArticleId&#x27;);
				fnProcessTriageList(this, this);
			} else {
				var query &#x3D; fnNeedTokenInfoQuery(&#x27;triage&#x27;);

				ctx.triageApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessTriageList);
				ctx.triageApi.setParent(this);
				ctx.triageApi.post();
			}
		}
	};

	// |delete| is a reserved word in some flavours of JS
	/**
	 * Deletes a page (for admins only).
	 *
	 * @param {Function} [onSuccess] - Callback function to run on success.
	 * @param {Function} [onFailure] - Callback function to run on failure.
	 */
	this.deletePage &#x3D; function(onSuccess, onFailure) {
		ctx.onDeleteSuccess &#x3D; onSuccess;
		ctx.onDeleteFailure &#x3D; onFailure || emptyFunction;

		if (!fnPreflightChecks.call(this, &#x27;delete&#x27;, ctx.onDeleteFailure)) {
			return; // abort
		}

		if (fnCanUseMwUserToken(&#x27;delete&#x27;)) {
			fnProcessDelete.call(this, this);
		} else {
			var query &#x3D; fnNeedTokenInfoQuery(&#x27;delete&#x27;);

			ctx.deleteApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessDelete, ctx.statusElement, ctx.onDeleteFailure);
			ctx.deleteApi.setParent(this);
			ctx.deleteApi.post();
		}
	};

	/**
	 * Undeletes a page (for admins only).
	 *
	 * @param {Function} [onSuccess] - Callback function to run on success.
	 * @param {Function} [onFailure] - Callback function to run on failure.
	 */
	this.undeletePage &#x3D; function(onSuccess, onFailure) {
		ctx.onUndeleteSuccess &#x3D; onSuccess;
		ctx.onUndeleteFailure &#x3D; onFailure || emptyFunction;

		if (!fnPreflightChecks.call(this, &#x27;undelete&#x27;, ctx.onUndeleteFailure)) {
			return; // abort
		}

		if (fnCanUseMwUserToken(&#x27;undelete&#x27;)) {
			fnProcessUndelete.call(this, this);
		} else {
			var query &#x3D; fnNeedTokenInfoQuery(&#x27;undelete&#x27;);

			ctx.undeleteApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessUndelete, ctx.statusElement, ctx.onUndeleteFailure);
			ctx.undeleteApi.setParent(this);
			ctx.undeleteApi.post();
		}
	};

	/**
	 * Protects a page (for admins only).
	 *
	 * @param {Function} [onSuccess] - Callback function to run on success.
	 * @param {Function} [onFailure] - Callback function to run on failure.
	 */
	this.protect &#x3D; function(onSuccess, onFailure) {
		ctx.onProtectSuccess &#x3D; onSuccess;
		ctx.onProtectFailure &#x3D; onFailure || emptyFunction;

		if (!fnPreflightChecks.call(this, &#x27;protect&#x27;, ctx.onProtectFailure)) {
			return; // abort
		}

		if (!ctx.protectEdit &amp;amp;&amp;amp; !ctx.protectMove &amp;amp;&amp;amp; !ctx.protectCreate) {
			ctx.statusElement.error(&#x27;Internal error: you must set edit and/or move and/or create protection before calling protect()!&#x27;);
			ctx.onProtectFailure(this);
			return;
		}

		// because of the way MW API interprets protection levels
		// (absolute, not differential), we always need to request
		// protection levels from the server
		var query &#x3D; fnNeedTokenInfoQuery(&#x27;protect&#x27;);

		ctx.protectApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessProtect, ctx.statusElement, ctx.onProtectFailure);
		ctx.protectApi.setParent(this);
		ctx.protectApi.post();
	};

	/**
	 * Apply FlaggedRevs protection settings.  Only works on wikis where
	 * the extension is installed (&#x60;$wgFlaggedRevsProtection &#x3D; true&#x60;
	 * i.e. where FlaggedRevs settings appear on the &quot;protect&quot; tab).
	 *
	 * @see {@link https://www.mediawiki.org/wiki/Extension:FlaggedRevs}
	 * Referred to as &quot;pending changes&quot; on-wiki.
	 *
	 * @param {Function} [onSuccess]
	 * @param {Function} [onFailure]
	 */
	this.stabilize &#x3D; function(onSuccess, onFailure) {
		ctx.onStabilizeSuccess &#x3D; onSuccess;
		ctx.onStabilizeFailure &#x3D; onFailure || emptyFunction;

		if (!fnPreflightChecks.call(this, &#x27;FlaggedRevs&#x27;, ctx.onStabilizeFailure)) {
			return; // abort
		}

		if (!ctx.flaggedRevs) {
			ctx.statusElement.error(&#x27;Internal error: you must set flaggedRevs before calling stabilize()!&#x27;);
			ctx.onStabilizeFailure(this);
			return;
		}

		if (fnCanUseMwUserToken(&#x27;stabilize&#x27;)) {
			fnProcessStabilize.call(this, this);
		} else {
			var query &#x3D; fnNeedTokenInfoQuery(&#x27;stabilize&#x27;);

			ctx.stabilizeApi &#x3D; new Morebits.wiki.api(&#x27;retrieving token...&#x27;, query, fnProcessStabilize, ctx.statusElement, ctx.onStabilizeFailure);
			ctx.stabilizeApi.setParent(this);
			ctx.stabilizeApi.post();
		}
	};

	/*
	 * Private member functions
	 * These are not exposed outside
	 */

	/**
	 * Determines whether we can save an API call by using the csrf token
	 * sent with the page HTML, or whether we need to ask the server for
	 * more info (e.g. protection or watchlist expiry).
	 *
	 * Currently used for &#x60;append&#x60;, &#x60;prepend&#x60;, &#x60;newSection&#x60;, &#x60;move&#x60;,
	 * &#x60;stabilize&#x60;, &#x60;deletePage&#x60;, and &#x60;undeletePage&#x60;. Not used for
	 * &#x60;protect&#x60; since it always needs to request protection status.
	 *
	 * @param {string} [action&#x3D;edit] - The action being undertaken, e.g.
	 * &quot;edit&quot; or &quot;delete&quot;. In practice, only &quot;edit&quot; or &quot;notedit&quot; matters.
	 * @returns {boolean}
	 */
	var fnCanUseMwUserToken &#x3D; function(action) {
		action &#x3D; typeof action !&#x3D;&#x3D; &#x27;undefined&#x27; ? action : &#x27;edit&#x27;; // IE doesn&#x27;t support default parameters

		// If a watchlist expiry is set, we must always load the page
		// to avoid overwriting indefinite protection
		if (ctx.watchlistExpiry) {
			return false;
		}

		// API-based redirect resolution only works for action&#x3D;query and
		// action&#x3D;edit in append/prepend/new modes
		if (ctx.followRedirect) {
			if (!ctx.followCrossNsRedirect) {
				return false; // must load the page to check for cross namespace redirects
			}
			if (action !&#x3D;&#x3D; &#x27;edit&#x27; || (ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;all&#x27; || ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;revert&#x27;)) {
				return false;
			}
		}

		// do we need to fetch the edit protection expiry?
		if (Morebits.userIsSysop &amp;amp;&amp;amp; !ctx.suppressProtectWarning) {
			if (new mw.Title(Morebits.pageNameNorm).getPrefixedText() !&#x3D;&#x3D; new mw.Title(ctx.pageName).getPrefixedText()) {
				return false;
			}

			// wgRestrictionEdit is null on non-existent pages,
			// so this neatly handles nonexistent pages
			var editRestriction &#x3D; mw.config.get(&#x27;wgRestrictionEdit&#x27;);
			if (!editRestriction || editRestriction.indexOf(&#x27;sysop&#x27;) !&#x3D;&#x3D; -1) {
				return false;
			}
		}

		return !!mw.user.tokens.get(&#x27;csrfToken&#x27;);
	};

	/**
	 * When functions can&#x27;t use
	 * {@link Morebits.wiki.page~fnCanUseMwUserToken|fnCanUseMwUserToken}
	 * or require checking protection or watched status, maintain the query
	 * in one place. Used for {@link Morebits.wiki.page#deletePage|delete},
	 * {@link Morebits.wiki.page#undeletePage|undelete},
	 * {@link* Morebits.wiki.page#protect|protect},
	 * {@link Morebits.wiki.page#stabilize|stabilize},
	 * and {@link Morebits.wiki.page#move|move}
	 * (basically, just not {@link Morebits.wiki.page#load|load}).
	 *
	 * @param {string} action - The action being undertaken, e.g. &quot;edit&quot; or
	 * &quot;delete&quot;.
	 * @returns {object} Appropriate query.
	 */
	var fnNeedTokenInfoQuery &#x3D; function(action) {
		var query &#x3D; {
			action: &#x27;query&#x27;,
			meta: &#x27;tokens&#x27;,
			type: &#x27;csrf&#x27;,
			titles: ctx.pageName,
			prop: &#x27;info&#x27;,
			inprop: &#x27;watched&#x27;,
			format: &#x27;json&#x27;
		};
		// Protection not checked for flagged-revs or non-sysop moves
		if (action !&#x3D;&#x3D; &#x27;stabilize&#x27; &amp;amp;&amp;amp; (action !&#x3D;&#x3D; &#x27;move&#x27; || Morebits.userIsSysop)) {
			query.inprop +&#x3D; &#x27;|protection&#x27;;
		}
		if (ctx.followRedirect &amp;amp;&amp;amp; action !&#x3D;&#x3D; &#x27;undelete&#x27;) {
			query.redirects &#x3D; &#x27;&#x27;; // follow all redirects
		}
		return query;
	};

	// callback from loadSuccess() for append(), prepend(), and newSection() threads
	var fnAutoSave &#x3D; function(pageobj) {
		pageobj.save(ctx.onSaveSuccess, ctx.onSaveFailure);
	};

	// callback from loadApi.post()
	var fnLoadSuccess &#x3D; function() {
		var response &#x3D; ctx.loadApi.getResponse().query;

		if (!fnCheckPageName(response, ctx.onLoadFailure)) {
			return; // abort
		}

		var page &#x3D; response.pages[0], rev;
		ctx.pageExists &#x3D; !page.missing;
		if (ctx.pageExists) {
			rev &#x3D; page.revisions[0];
			ctx.lastEditTime &#x3D; rev.timestamp;
			ctx.pageText &#x3D; rev.content;
			ctx.pageID &#x3D; page.pageid;
		} else {
			ctx.pageText &#x3D; &#x27;&#x27;;  // allow for concatenation, etc.
			ctx.pageID &#x3D; 0; // nonexistent in response, matches wgArticleId
		}
		ctx.csrfToken &#x3D; response.tokens.csrftoken;
		if (!ctx.csrfToken) {
			ctx.statusElement.error(&#x27;Failed to retrieve edit token.&#x27;);
			ctx.onLoadFailure(this);
			return;
		}
		ctx.loadTime &#x3D; ctx.loadApi.getResponse().curtimestamp;
		if (!ctx.loadTime) {
			ctx.statusElement.error(&#x27;Failed to retrieve current timestamp.&#x27;);
			ctx.onLoadFailure(this);
			return;
		}

		ctx.contentModel &#x3D; page.contentmodel;
		ctx.watched &#x3D; page.watchlistexpiry || page.watched;

		// extract protection info, to alert admins when they are about to edit a protected page
		// Includes cascading protection
		if (Morebits.userIsSysop) {
			var editProt &#x3D; page.protection.filter(function(pr) {
				return pr.type &#x3D;&#x3D;&#x3D; &#x27;edit&#x27; &amp;amp;&amp;amp; pr.level &#x3D;&#x3D;&#x3D; &#x27;sysop&#x27;;
			}).pop();
			if (editProt) {
				ctx.fullyProtected &#x3D; editProt.expiry;
			} else {
				ctx.fullyProtected &#x3D; false;
			}
		}

		ctx.revertCurID &#x3D; page.lastrevid;

		var testactions &#x3D; page.actions;
		ctx.testActions &#x3D; []; // was null
		Object.keys(testactions).forEach(function(action) {
			if (testactions[action]) {
				ctx.testActions.push(action);
			}
		});

		if (ctx.editMode &#x3D;&#x3D;&#x3D; &#x27;revert&#x27;) {
			ctx.revertCurID &#x3D; rev &amp;amp;&amp;amp; rev.revid;
			if (!ctx.revertCurID) {
				ctx.statusElement.error(&#x27;Failed to retrieve current revision ID.&#x27;);
				ctx.onLoadFailure(this);
				return;
			}
			ctx.revertUser &#x3D; rev &amp;amp;&amp;amp; rev.user;
			if (!ctx.revertUser) {
				if (rev &amp;amp;&amp;amp; rev.userhidden) {  // username was RevDel&#x27;d or oversighted
					ctx.revertUser &#x3D; &#x27;&amp;lt;username hidden&gt;&#x27;;
				} else {
					ctx.statusElement.error(&#x27;Failed to retrieve user who made the revision.&#x27;);
					ctx.onLoadFailure(this);
					return;
				}
			}
			// set revert edit summary
			ctx.editSummary &#x3D; &#x27;[[Help:Revert|Reverted]] to revision &#x27; + ctx.revertOldID + &#x27; by &#x27; + ctx.revertUser + &#x27;: &#x27; + ctx.editSummary;
		}

		ctx.pageLoaded &#x3D; true;

		// alert(&quot;Generate edit conflict now&quot;);  // for testing edit conflict recovery logic
		ctx.onLoadSuccess(this);  // invoke callback
	};

	// helper function to parse the page name returned from the API
	var fnCheckPageName &#x3D; function(response, onFailure) {
		if (!onFailure) {
			onFailure &#x3D; emptyFunction;
		}

		var page &#x3D; response.pages &amp;amp;&amp;amp; response.pages[0];
		if (page) {
			// check for invalid titles
			if (page.invalid) {
				ctx.statusElement.error(&#x27;The page title is invalid: &#x27; + ctx.pageName);
				onFailure(this);
				return false; // abort
			}

			// retrieve actual title of the page after normalization and redirects
			var resolvedName &#x3D; page.title;

			if (response.redirects) {
				// check for cross-namespace redirect:
				var origNs &#x3D; new mw.Title(ctx.pageName).namespace;
				var newNs &#x3D; new mw.Title(resolvedName).namespace;
				if (origNs !&#x3D;&#x3D; newNs &amp;amp;&amp;amp; !ctx.followCrossNsRedirect) {
					ctx.statusElement.error(ctx.pageName + &#x27; is a cross-namespace redirect to &#x27; + resolvedName + &#x27;, aborted&#x27;);
					onFailure(this);
					return false;
				}

				// only notify user for redirects, not normalization
				new Morebits.status(&#x27;Note&#x27;, &#x27;Redirected from &#x27; + ctx.pageName + &#x27; to &#x27; + resolvedName);
			}

			ctx.pageName &#x3D; resolvedName; // update to redirect target or normalized name

		} else {
			// could be a circular redirect or other problem
			ctx.statusElement.error(&#x27;Could not resolve redirects for: &#x27; + ctx.pageName);
			onFailure(this);

			// force error to stay on the screen
			++Morebits.wiki.numberOfActionsLeft;
			return false; // abort
		}
		return true; // all OK
	};

	// callback from saveApi.post()
	var fnSaveSuccess &#x3D; function() {
		ctx.editMode &#x3D; &#x27;all&#x27;;  // cancel append/prepend/newSection/revert modes
		var response &#x3D; ctx.saveApi.getResponse();

		// see if the API thinks we were successful
		if (response.edit.result &#x3D;&#x3D;&#x3D; &#x27;Success&#x27;) {

			// real success
			// default on success action - display link for edited page
			var link &#x3D; document.createElement(&#x27;a&#x27;);
			link.setAttribute(&#x27;href&#x27;, mw.util.getUrl(ctx.pageName));
			link.appendChild(document.createTextNode(ctx.pageName));
			ctx.statusElement.info([&#x27;completed (&#x27;, link, &#x27;)&#x27;]);
			if (ctx.onSaveSuccess) {
				ctx.onSaveSuccess(this);  // invoke callback
			}
			return;
		}

		// errors here are only generated by extensions which hook APIEditBeforeSave within MediaWiki,
		// which as of 1.34.0-wmf.23 (Sept 2019) should only encompass captcha messages
		if (response.edit.captcha) {
			ctx.statusElement.error(&#x27;Could not save the page because the wiki server wanted you to fill out a CAPTCHA.&#x27;);
		} else {
			ctx.statusElement.error(&#x27;Unknown error received from API while saving page&#x27;);
		}

		// force error to stay on the screen
		++Morebits.wiki.numberOfActionsLeft;

		ctx.onSaveFailure(this);
	};

	// callback from saveApi.post()
	var fnSaveError &#x3D; function() {
		var errorCode &#x3D; ctx.saveApi.getErrorCode();

		// check for edit conflict
		if (errorCode &#x3D;&#x3D;&#x3D; &#x27;editconflict&#x27; &amp;amp;&amp;amp; ctx.conflictRetries++ &amp;lt; ctx.maxConflictRetries) {

			// edit conflicts can occur when the page needs to be purged from the server cache
			var purgeQuery &#x3D; {
				action: &#x27;purge&#x27;,
				titles: ctx.pageName  // redirects are already resolved
			};

			var purgeApi &#x3D; new Morebits.wiki.api(&#x27;Edit conflict detected, purging server cache&#x27;, purgeQuery, function() {
				--Morebits.wiki.numberOfActionsLeft;  // allow for normal completion if retry succeeds

				ctx.statusElement.info(&#x27;Edit conflict detected, reapplying edit&#x27;);
				if (fnCanUseMwUserToken(&#x27;edit&#x27;)) {
					ctx.saveApi.post(); // necessarily append, prepend, or newSection, so this should work as desired
				} else {
					ctx.loadApi.post(); // reload the page and reapply the edit
				}
			}, ctx.statusElement);
			purgeApi.post();

		// check for network or server error
		} else if ((errorCode &#x3D;&#x3D;&#x3D; null || errorCode &#x3D;&#x3D;&#x3D; undefined) &amp;amp;&amp;amp; ctx.retries++ &amp;lt; ctx.maxRetries) {

			// the error might be transient, so try again
			ctx.statusElement.info(&#x27;Save failed, retrying in 2 seconds ...&#x27;);
			--Morebits.wiki.numberOfActionsLeft;  // allow for normal completion if retry succeeds

			// wait for sometime for client to regain connnectivity
			sleep(2000).then(function() {
				ctx.saveApi.post(); // give it another go!
			});

		// hard error, give up
		} else {

			switch (errorCode) {

				case &#x27;protectedpage&#x27;:
					// non-admin attempting to edit a protected page - this gives a friendlier message than the default
					ctx.statusElement.error(&#x27;Failed to save edit: Page is protected&#x27;);
					break;

				case &#x27;abusefilter-disallowed&#x27;:
					ctx.statusElement.error(&#x27;The edit was disallowed by the edit filter: &quot;&#x27; + ctx.saveApi.getResponse().error.abusefilter.description + &#x27;&quot;.&#x27;);
					break;

				case &#x27;abusefilter-warning&#x27;:
					ctx.statusElement.error([ &#x27;A warning was returned by the edit filter: &quot;&#x27;, ctx.saveApi.getResponse().error.abusefilter.description, &#x27;&quot;. If you wish to proceed with the edit, please carry it out again. This warning will not appear a second time.&#x27; ]);
					// We should provide the user with a way to automatically retry the action if they so choose -
					// I can&#x27;t see how to do this without creating a UI dependency on Morebits.wiki.page though -- TTO
					break;

				case &#x27;spamblacklist&#x27;:
					// If multiple items are blacklisted, we only return the first
					var spam &#x3D; ctx.saveApi.getResponse().error.spamblacklist.matches[0];
					ctx.statusElement.error(&#x27;Could not save the page because the URL &#x27; + spam + &#x27; is on the spam blacklist&#x27;);
					break;

				default:
					ctx.statusElement.error(&#x27;Failed to save edit: &#x27; + ctx.saveApi.getErrorText());
			}

			ctx.editMode &#x3D; &#x27;all&#x27;;  // cancel append/prepend/newSection/revert modes
			if (ctx.onSaveFailure) {
				ctx.onSaveFailure(this);  // invoke callback
			}
		}
	};

	var fnLookupCreationSuccess &#x3D; function() {
		var response &#x3D; ctx.lookupCreationApi.getResponse().query;

		if (!fnCheckPageName(response)) {
			return; // abort
		}

		var rev &#x3D; response.pages[0].revisions &amp;amp;&amp;amp; response.pages[0].revisions[0];
		if (!rev) {
			ctx.statusElement.error(&#x27;Could not find any revisions of &#x27; + ctx.pageName);
			return;
		}

		if (!ctx.lookupNonRedirectCreator || !/^\s*#redirect/i.test(rev.content)) {

			ctx.creator &#x3D; rev.user;
			if (!ctx.creator) {
				ctx.statusElement.error(&#x27;Could not find name of page creator&#x27;);
				return;
			}
			ctx.timestamp &#x3D; rev.timestamp;
			if (!ctx.timestamp) {
				ctx.statusElement.error(&#x27;Could not find timestamp of page creation&#x27;);
				return;
			}
			ctx.onLookupCreationSuccess(this);

		} else {
			ctx.lookupCreationApi.query.rvlimit &#x3D; 50; // modify previous query to fetch more revisions
			ctx.lookupCreationApi.query.titles &#x3D; ctx.pageName; // update pageName if redirect resolution took place in earlier query

			ctx.lookupCreationApi &#x3D; new Morebits.wiki.api(&#x27;Retrieving page creation information&#x27;, ctx.lookupCreationApi.query, fnLookupNonRedirectCreator, ctx.statusElement);
			ctx.lookupCreationApi.setParent(this);
			ctx.lookupCreationApi.post();
		}

	};

	var fnLookupNonRedirectCreator &#x3D; function() {
		var response &#x3D; ctx.lookupCreationApi.getResponse().query;
		var revs &#x3D; response.pages[0].revisions;

		for (var i &#x3D; 0; i &amp;lt; revs.length; i++) {
			if (!/^\s*#redirect/i.test(revs[i].content)) { // inaccessible revisions also check out
				ctx.creator &#x3D; revs[i].user;
				ctx.timestamp &#x3D; revs[i].timestamp;
				break;
			}
		}

		if (!ctx.creator) {
			// fallback to give first revision author if no non-redirect version in the first 50
			ctx.creator &#x3D; revs[0].user;
			ctx.timestamp &#x3D; revs[0].timestamp;
			if (!ctx.creator) {
				ctx.statusElement.error(&#x27;Could not find name of page creator&#x27;);
				return;
			}

		}
		if (!ctx.timestamp) {
			ctx.statusElement.error(&#x27;Could not find timestamp of page creation&#x27;);
			return;
		}

		ctx.onLookupCreationSuccess(this);

	};

	/**
	 * Common checks for action methods. Used for move, undelete, delete,
	 * protect, stabilize.
	 *
	 * @param {string} action - The action being checked.
	 * @param {string} onFailure - Failure callback.
	 * @returns {boolean}
	 */
	var fnPreflightChecks &#x3D; function(action, onFailure) {
		// if a non-admin tries to do this, don&#x27;t bother
		if (!Morebits.userIsSysop &amp;amp;&amp;amp; action !&#x3D;&#x3D; &#x27;move&#x27;) {
			ctx.statusElement.error(&#x27;Cannot &#x27; + action + &#x27;page : only admins can do that&#x27;);
			onFailure(this);
			return false;
		}

		if (!ctx.editSummary) {
			ctx.statusElement.error(&#x27;Internal error: &#x27; + action + &#x27; reason not set (use setEditSummary function)!&#x27;);
			onFailure(this);
			return false;
		}
		return true; // all OK
	};

	/**
	 * Common checks for fnProcess functions (&#x60;fnProcessDelete&#x60;, &#x60;fnProcessMove&#x60;, etc.
	 * Used for move, undelete, delete, protect, stabilize.
	 *
	 * @param {string} action - The action being checked.
	 * @param {string} onFailure - Failure callback.
	 * @param {string} response - The response document from the API call.
	 * @returns {boolean}
	 */
	var fnProcessChecks &#x3D; function(action, onFailure, response) {
		var missing &#x3D; response.pages[0].missing;

		// No undelete as an existing page could have deleted revisions
		var actionMissing &#x3D; missing &amp;amp;&amp;amp; [&#x27;delete&#x27;, &#x27;stabilize&#x27;, &#x27;move&#x27;].indexOf(action) !&#x3D;&#x3D; -1;
		var protectMissing &#x3D; action &#x3D;&#x3D;&#x3D; &#x27;protect&#x27; &amp;amp;&amp;amp; missing &amp;amp;&amp;amp; (ctx.protectEdit || ctx.protectMove);
		var saltMissing &#x3D; action &#x3D;&#x3D;&#x3D; &#x27;protect&#x27; &amp;amp;&amp;amp; !missing &amp;amp;&amp;amp; ctx.protectCreate;

		if (actionMissing || protectMissing || saltMissing) {
			ctx.statusElement.error(&#x27;Cannot &#x27; + action + &#x27; the page because it &#x27; + (missing ? &#x27;no longer&#x27; : &#x27;already&#x27;) + &#x27; exists&#x27;);
			onFailure(this);
			return false;
		}

		// Delete, undelete, move
		// extract protection info
		var editprot;
		if (action &#x3D;&#x3D;&#x3D; &#x27;undelete&#x27;) {
			editprot &#x3D; response.pages[0].protection.filter(function(pr) {
				return pr.type &#x3D;&#x3D;&#x3D; &#x27;create&#x27; &amp;amp;&amp;amp; pr.level &#x3D;&#x3D;&#x3D; &#x27;sysop&#x27;;
			}).pop();
		} else if (action &#x3D;&#x3D;&#x3D; &#x27;delete&#x27; || action &#x3D;&#x3D;&#x3D; &#x27;move&#x27;) {
			editprot &#x3D; response.pages[0].protection.filter(function(pr) {
				return pr.type &#x3D;&#x3D;&#x3D; &#x27;edit&#x27; &amp;amp;&amp;amp; pr.level &#x3D;&#x3D;&#x3D; &#x27;sysop&#x27;;
			}).pop();
		}
		if (editprot &amp;amp;&amp;amp; !ctx.suppressProtectWarning &amp;amp;&amp;amp;
			!confirm(&#x27;You are about to &#x27; + action + &#x27; the fully protected page &quot;&#x27; + ctx.pageName +
			(editprot.expiry &#x3D;&#x3D;&#x3D; &#x27;infinity&#x27; ? &#x27;&quot; (protected indefinitely)&#x27; : &#x27;&quot; (protection expiring &#x27; + new Morebits.date(editprot.expiry).calendar(&#x27;utc&#x27;) + &#x27; (UTC))&#x27;) +
			&#x27;.  \n\nClick OK to proceed with &#x27; + action + &#x27;, or Cancel to skip.&#x27;)) {
			ctx.statusElement.error(&#x27;Aborted &#x27; + action + &#x27; on fully protected page.&#x27;);
			onFailure(this);
			return false;
		}

		if (!response.tokens.csrftoken) {
			ctx.statusElement.error(&#x27;Failed to retrieve token.&#x27;);
			onFailure(this);
			return false;
		}
		return true; // all OK
	};

	var fnProcessMove &#x3D; function() {
		var pageTitle, token;

		if (fnCanUseMwUserToken(&#x27;move&#x27;)) {
			token &#x3D; mw.user.tokens.get(&#x27;csrfToken&#x27;);
			pageTitle &#x3D; ctx.pageName;
		} else {
			var response &#x3D; ctx.moveApi.getResponse().query;

			if (!fnProcessChecks(&#x27;move&#x27;, ctx.onMoveFailure, response)) {
				return; // abort
			}

			token &#x3D; response.tokens.csrftoken;
			var page &#x3D; response.pages[0];
			pageTitle &#x3D; page.title;
			ctx.watched &#x3D; page.watchlistexpiry || page.watched;
		}

		var query &#x3D; {
			action: &#x27;move&#x27;,
			from: pageTitle,
			to: ctx.moveDestination,
			token: token,
			reason: ctx.editSummary,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}
		if (ctx.moveTalkPage) {
			query.movetalk &#x3D; &#x27;true&#x27;;
		}
		if (ctx.moveSubpages) {
			query.movesubpages &#x3D; &#x27;true&#x27;;
		}
		if (ctx.moveSuppressRedirect) {
			query.noredirect &#x3D; &#x27;true&#x27;;
		}

		ctx.moveProcessApi &#x3D; new Morebits.wiki.api(&#x27;moving page...&#x27;, query, ctx.onMoveSuccess, ctx.statusElement, ctx.onMoveFailure);
		ctx.moveProcessApi.setParent(this);
		ctx.moveProcessApi.post();
	};

	var fnProcessPatrol &#x3D; function() {
		var query &#x3D; {
			action: &#x27;patrol&#x27;,
			format: &#x27;json&#x27;
		};

		// Didn&#x27;t need to load the page
		if (ctx.rcid) {
			query.rcid &#x3D; ctx.rcid;
			query.token &#x3D; mw.user.tokens.get(&#x27;patrolToken&#x27;);
		} else {
			var response &#x3D; ctx.patrolApi.getResponse().query;

			// Don&#x27;t patrol if not unpatrolled
			if (!response.recentchanges[0].unpatrolled) {
				return;
			}

			var lastrevid &#x3D; response.pages[0].lastrevid;
			if (!lastrevid) {
				return;
			}
			query.revid &#x3D; lastrevid;

			var token &#x3D; response.tokens.csrftoken;
			if (!token) {
				return;
			}
			query.token &#x3D; token;
		}
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		var patrolStat &#x3D; new Morebits.status(&#x27;Marking page as patrolled&#x27;);

		ctx.patrolProcessApi &#x3D; new Morebits.wiki.api(&#x27;patrolling page...&#x27;, query, null, patrolStat);
		ctx.patrolProcessApi.setParent(this);
		ctx.patrolProcessApi.post();
	};

	// Ensure that the page is curatable
	var fnProcessTriageList &#x3D; function() {
		if (ctx.pageID) {
			ctx.csrfToken &#x3D; mw.user.tokens.get(&#x27;csrfToken&#x27;);
		} else {
			var response &#x3D; ctx.triageApi.getResponse().query;

			ctx.pageID &#x3D; response.pages[0].pageid;
			if (!ctx.pageID) {
				return;
			}

			ctx.csrfToken &#x3D; response.tokens.csrftoken;
			if (!ctx.csrfToken) {
				return;
			}
		}

		var query &#x3D; {
			action: &#x27;pagetriagelist&#x27;,
			page_id: ctx.pageID,
			format: &#x27;json&#x27;
		};

		ctx.triageProcessListApi &#x3D; new Morebits.wiki.api(&#x27;checking curation status...&#x27;, query, fnProcessTriage);
		ctx.triageProcessListApi.setParent(this);
		ctx.triageProcessListApi.post();
	};

	// callback from triageProcessListApi.post()
	var fnProcessTriage &#x3D; function() {
		var responseList &#x3D; ctx.triageProcessListApi.getResponse().pagetriagelist;
		// Exit if not in the queue
		if (!responseList || responseList.result !&#x3D;&#x3D; &#x27;success&#x27;) {
			return;
		}
		var page &#x3D; responseList.pages &amp;amp;&amp;amp; responseList.pages[0];
		// Do nothing if page already triaged/patrolled
		if (!page || !parseInt(page.patrol_status, 10)) {
			var query &#x3D; {
				action: &#x27;pagetriageaction&#x27;,
				pageid: ctx.pageID,
				reviewed: 1,
				// tags: ctx.changeTags, // pagetriage tag support: [[phab:T252980]]
				// Could use an adder to modify/create note:
				// summaryAd, but that seems overwrought
				token: ctx.csrfToken,
				format: &#x27;json&#x27;
			};
			var triageStat &#x3D; new Morebits.status(&#x27;Marking page as curated&#x27;);
			ctx.triageProcessApi &#x3D; new Morebits.wiki.api(&#x27;curating page...&#x27;, query, null, triageStat);
			ctx.triageProcessApi.setParent(this);
			ctx.triageProcessApi.post();
		}
	};

	var fnProcessDelete &#x3D; function() {
		var pageTitle, token;

		if (fnCanUseMwUserToken(&#x27;delete&#x27;)) {
			token &#x3D; mw.user.tokens.get(&#x27;csrfToken&#x27;);
			pageTitle &#x3D; ctx.pageName;
		} else {
			var response &#x3D; ctx.deleteApi.getResponse().query;

			if (!fnProcessChecks(&#x27;delete&#x27;, ctx.onDeleteFailure, response)) {
				return; // abort
			}

			token &#x3D; response.tokens.csrftoken;
			var page &#x3D; response.pages[0];
			pageTitle &#x3D; page.title;
			ctx.watched &#x3D; page.watchlistexpiry || page.watched;
		}

		var query &#x3D; {
			action: &#x27;delete&#x27;,
			title: pageTitle,
			token: token,
			reason: ctx.editSummary,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}

		ctx.deleteProcessApi &#x3D; new Morebits.wiki.api(&#x27;deleting page...&#x27;, query, ctx.onDeleteSuccess, ctx.statusElement, fnProcessDeleteError);
		ctx.deleteProcessApi.setParent(this);
		ctx.deleteProcessApi.post();
	};

	// callback from deleteProcessApi.post()
	var fnProcessDeleteError &#x3D; function() {

		var errorCode &#x3D; ctx.deleteProcessApi.getErrorCode();

		// check for &quot;Database query error&quot;
		if (errorCode &#x3D;&#x3D;&#x3D; &#x27;internal_api_error_DBQueryError&#x27; &amp;amp;&amp;amp; ctx.retries++ &amp;lt; ctx.maxRetries) {
			ctx.statusElement.info(&#x27;Database query error, retrying&#x27;);
			--Morebits.wiki.numberOfActionsLeft;  // allow for normal completion if retry succeeds
			ctx.deleteProcessApi.post(); // give it another go!

		} else if (errorCode &#x3D;&#x3D;&#x3D; &#x27;missingtitle&#x27;) {
			ctx.statusElement.error(&#x27;Cannot delete the page, because it no longer exists&#x27;);
			if (ctx.onDeleteFailure) {
				ctx.onDeleteFailure.call(this, ctx.deleteProcessApi);  // invoke callback
			}
		// hard error, give up
		} else {
			ctx.statusElement.error(&#x27;Failed to delete the page: &#x27; + ctx.deleteProcessApi.getErrorText());
			if (ctx.onDeleteFailure) {
				ctx.onDeleteFailure.call(this, ctx.deleteProcessApi);  // invoke callback
			}
		}
	};

	var fnProcessUndelete &#x3D; function() {
		var pageTitle, token;

		if (fnCanUseMwUserToken(&#x27;undelete&#x27;)) {
			token &#x3D; mw.user.tokens.get(&#x27;csrfToken&#x27;);
			pageTitle &#x3D; ctx.pageName;
		} else {
			var response &#x3D; ctx.undeleteApi.getResponse().query;

			if (!fnProcessChecks(&#x27;undelete&#x27;, ctx.onUndeleteFailure, response)) {
				return; // abort
			}

			token &#x3D; response.tokens.csrftoken;
			var page &#x3D; response.pages[0];
			pageTitle &#x3D; page.title;
			ctx.watched &#x3D; page.watchlistexpiry || page.watched;
		}

		var query &#x3D; {
			action: &#x27;undelete&#x27;,
			title: pageTitle,
			token: token,
			reason: ctx.editSummary,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}

		ctx.undeleteProcessApi &#x3D; new Morebits.wiki.api(&#x27;undeleting page...&#x27;, query, ctx.onUndeleteSuccess, ctx.statusElement, fnProcessUndeleteError);
		ctx.undeleteProcessApi.setParent(this);
		ctx.undeleteProcessApi.post();
	};

	// callback from undeleteProcessApi.post()
	var fnProcessUndeleteError &#x3D; function() {

		var errorCode &#x3D; ctx.undeleteProcessApi.getErrorCode();

		// check for &quot;Database query error&quot;
		if (errorCode &#x3D;&#x3D;&#x3D; &#x27;internal_api_error_DBQueryError&#x27;) {
			if (ctx.retries++ &amp;lt; ctx.maxRetries) {
				ctx.statusElement.info(&#x27;Database query error, retrying&#x27;);
				--Morebits.wiki.numberOfActionsLeft;  // allow for normal completion if retry succeeds
				ctx.undeleteProcessApi.post(); // give it another go!
			} else {
				ctx.statusElement.error(&#x27;Repeated database query error, please try again&#x27;);
				if (ctx.onUndeleteFailure) {
					ctx.onUndeleteFailure.call(this, ctx.undeleteProcessApi);  // invoke callback
				}
			}
		} else if (errorCode &#x3D;&#x3D;&#x3D; &#x27;cantundelete&#x27;) {
			ctx.statusElement.error(&#x27;Cannot undelete the page, either because there are no revisions to undelete or because it has already been undeleted&#x27;);
			if (ctx.onUndeleteFailure) {
				ctx.onUndeleteFailure.call(this, ctx.undeleteProcessApi);  // invoke callback
			}
		// hard error, give up
		} else {
			ctx.statusElement.error(&#x27;Failed to undelete the page: &#x27; + ctx.undeleteProcessApi.getErrorText());
			if (ctx.onUndeleteFailure) {
				ctx.onUndeleteFailure.call(this, ctx.undeleteProcessApi);  // invoke callback
			}
		}
	};

	var fnProcessProtect &#x3D; function() {
		var response &#x3D; ctx.protectApi.getResponse().query;

		if (!fnProcessChecks(&#x27;protect&#x27;, ctx.onProtectFailure, response)) {
			return; // abort
		}

		var token &#x3D; response.tokens.csrftoken;
		var page &#x3D; response.pages[0];
		var pageTitle &#x3D; page.title;
		ctx.watched &#x3D; page.watchlistexpiry || page.watched;

		// Fetch existing protection levels
		var prs &#x3D; response.pages[0].protection;
		var editprot, moveprot, createprot;
		prs.forEach(function(pr) {
			// Filter out protection from cascading
			if (pr.type &#x3D;&#x3D;&#x3D; &#x27;edit&#x27; &amp;amp;&amp;amp; !pr.source) {
				editprot &#x3D; pr;
			} else if (pr.type &#x3D;&#x3D;&#x3D; &#x27;move&#x27;) {
				moveprot &#x3D; pr;
			} else if (pr.type &#x3D;&#x3D;&#x3D; &#x27;create&#x27;) {
				createprot &#x3D; pr;
			}
		});


		// Fall back to current levels if not explicitly set
		if (!ctx.protectEdit &amp;amp;&amp;amp; editprot) {
			ctx.protectEdit &#x3D; { level: editprot.level, expiry: editprot.expiry };
		}
		if (!ctx.protectMove &amp;amp;&amp;amp; moveprot) {
			ctx.protectMove &#x3D; { level: moveprot.level, expiry: moveprot.expiry };
		}
		if (!ctx.protectCreate &amp;amp;&amp;amp; createprot) {
			ctx.protectCreate &#x3D; { level: createprot.level, expiry: createprot.expiry };
		}

		// Default to pre-existing cascading protection if unchanged (similar to above)
		if (ctx.protectCascade &#x3D;&#x3D;&#x3D; null) {
			ctx.protectCascade &#x3D; !!prs.filter(function(pr) {
				return pr.cascade;
			}).length;
		}
		// Warn if cascading protection being applied with an invalid protection level,
		// which for edit protection will cause cascading to be silently stripped
		if (ctx.protectCascade) {
			// On move protection, this is technically stricter than the MW API,
			// but seems reasonable to avoid dumb values and misleading log entries (T265626)
			if (((!ctx.protectEdit || ctx.protectEdit.level !&#x3D;&#x3D; &#x27;sysop&#x27;) ||
				(!ctx.protectMove || ctx.protectMove.level !&#x3D;&#x3D; &#x27;sysop&#x27;)) &amp;amp;&amp;amp;
				!confirm(&#x27;You have cascading protection enabled on &quot;&#x27; + ctx.pageName +
				&#x27;&quot; but have not selected uniform sysop-level protection.\n\n&#x27; +
				&#x27;Click OK to adjust and proceed with sysop-level cascading protection, or Cancel to skip this action.&#x27;)) {
				ctx.statusElement.error(&#x27;Cascading protection was aborted.&#x27;);
				ctx.onProtectFailure(this);
				return;
			}

			ctx.protectEdit.level &#x3D; &#x27;sysop&#x27;;
			ctx.protectMove.level &#x3D; &#x27;sysop&#x27;;
		}

		// Build protection levels and expirys (expiries?) for query
		var protections &#x3D; [], expirys &#x3D; [];
		if (ctx.protectEdit) {
			protections.push(&#x27;edit&#x3D;&#x27; + ctx.protectEdit.level);
			expirys.push(ctx.protectEdit.expiry);
		}

		if (ctx.protectMove) {
			protections.push(&#x27;move&#x3D;&#x27; + ctx.protectMove.level);
			expirys.push(ctx.protectMove.expiry);
		}

		if (ctx.protectCreate) {
			protections.push(&#x27;create&#x3D;&#x27; + ctx.protectCreate.level);
			expirys.push(ctx.protectCreate.expiry);
		}

		var query &#x3D; {
			action: &#x27;protect&#x27;,
			title: pageTitle,
			token: token,
			protections: protections.join(&#x27;|&#x27;),
			expiry: expirys.join(&#x27;|&#x27;),
			reason: ctx.editSummary,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};
		// Only shows up in logs, not page history [[phab:T259983]]
		if (ctx.changeTags) {
			query.tags &#x3D; ctx.changeTags;
		}

		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}
		if (ctx.protectCascade) {
			query.cascade &#x3D; &#x27;true&#x27;;
		}

		ctx.protectProcessApi &#x3D; new Morebits.wiki.api(&#x27;protecting page...&#x27;, query, ctx.onProtectSuccess, ctx.statusElement, ctx.onProtectFailure);
		ctx.protectProcessApi.setParent(this);
		ctx.protectProcessApi.post();
	};

	var fnProcessStabilize &#x3D; function() {
		var pageTitle, token;

		if (fnCanUseMwUserToken(&#x27;stabilize&#x27;)) {
			token &#x3D; mw.user.tokens.get(&#x27;csrfToken&#x27;);
			pageTitle &#x3D; ctx.pageName;
		} else {
			var response &#x3D; ctx.stabilizeApi.getResponse().query;

			// &#x27;stabilize&#x27; as a verb not necessarily well understood
			if (!fnProcessChecks(&#x27;stabilize&#x27;, ctx.onStabilizeFailure, response)) {
				return; // abort
			}

			token &#x3D; response.tokens.csrftoken;
			var page &#x3D; response.pages[0];
			pageTitle &#x3D; page.title;
			// Doesn&#x27;t support watchlist expiry [[phab:T263336]]
			// ctx.watched &#x3D; page.watchlistexpiry || page.watched;
		}

		var query &#x3D; {
			action: &#x27;stabilize&#x27;,
			title: pageTitle,
			token: token,
			protectlevel: ctx.flaggedRevs.level,
			expiry: ctx.flaggedRevs.expiry,
			// tags: ctx.changeTags, // flaggedrevs tag support: [[phab:T247721]]
			reason: ctx.editSummary,
			watchlist: ctx.watchlistOption,
			format: &#x27;json&#x27;
		};

		/* Doesn&#x27;t support watchlist expiry [[phab:T263336]]
		if (ctx.watchlistExpiry &amp;amp;&amp;amp; ctx.watched !&#x3D;&#x3D; true) {
			query.watchlistexpiry &#x3D; ctx.watchlistExpiry;
		}
		*/

		ctx.stabilizeProcessApi &#x3D; new Morebits.wiki.api(&#x27;configuring stabilization settings...&#x27;, query, ctx.onStabilizeSuccess, ctx.statusElement, ctx.onStabilizeFailure);
		ctx.stabilizeProcessApi.setParent(this);
		ctx.stabilizeProcessApi.post();
	};

	var sleep &#x3D; function(milliseconds) {
		var deferred &#x3D; $.Deferred();
		setTimeout(deferred.resolve, milliseconds);
		return deferred;
	};

}; // end Morebits.wiki.page

/* Morebits.wiki.page TODO: (XXX)
* - Should we retry loads also?
* - Need to reset current action before the save?
* - Deal with action.completed stuff
* - Need to reset all parameters once done (e.g. edit summary, move destination, etc.)
*/


/* **************** Morebits.wiki.preview **************** */
/**
 * Use the API to parse a fragment of wikitext and render it as HTML.
 *
 * The suggested implementation pattern (in {@link Morebits.simpleWindow} and
 * {@link Morebits.quickForm} situations) is to construct a
 * &#x60;Morebits.wiki.preview&#x60; object after rendering a &#x60;Morebits.quickForm&#x60;, and
 * bind the object to an arbitrary property of the form (e.g. |previewer|).
 * For an example, see twinklewarn.js.
 *
 * @memberof Morebits.wiki
 * @class
 * @param {HTMLElement} previewbox - The element that will contain the rendered HTML,
 * usually a &amp;lt;div&gt; element.
 */
Morebits.wiki.preview &#x3D; function(previewbox) {
	this.previewbox &#x3D; previewbox;
	$(previewbox).addClass(&#x27;morebits-previewbox&#x27;).hide();

	/**
	 * Displays the preview box, and begins an asynchronous attempt
	 * to render the specified wikitext.
	 *
	 * @param {string} wikitext - Wikitext to render; most things should work, including &#x60;subst:&#x60; and &#x60;~~~~&#x60;.
	 * @param {string} [pageTitle] - Optional parameter for the page this should be rendered as being on, if omitted it is taken as the current page.
	 * @param {string} [sectionTitle] - If provided, render the text as a new section using this as the title.
	 */
	this.beginRender &#x3D; function(wikitext, pageTitle, sectionTitle) {
		$(previewbox).show();

		var statusspan &#x3D; document.createElement(&#x27;span&#x27;);
		previewbox.appendChild(statusspan);
		Morebits.status.init(statusspan);

		var query &#x3D; {
			action: &#x27;parse&#x27;,
			prop: &#x27;text&#x27;,
			pst: &#x27;true&#x27;,  // PST &#x3D; pre-save transform; this makes substitution work properly
			text: wikitext,
			title: pageTitle || mw.config.get(&#x27;wgPageName&#x27;),
			disablelimitreport: true,
			format: &#x27;json&#x27;
		};
		if (sectionTitle) {
			query.section &#x3D; &#x27;new&#x27;;
			query.sectiontitle &#x3D; sectionTitle;
		}
		var renderApi &#x3D; new Morebits.wiki.api(&#x27;loading...&#x27;, query, fnRenderSuccess, new Morebits.status(&#x27;Preview&#x27;));
		renderApi.post();
	};

	var fnRenderSuccess &#x3D; function(apiobj) {
		var html &#x3D; apiobj.getResponse().parse.text;
		if (!html) {
			apiobj.statelem.error(&#x27;failed to retrieve preview, or template was blanked&#x27;);
			return;
		}
		previewbox.innerHTML &#x3D; html;
		$(previewbox).find(&#x27;a&#x27;).attr(&#x27;target&#x27;, &#x27;_blank&#x27;); // this makes links open in new tab
	};

	/** Hides the preview box and clears it. */
	this.closePreview &#x3D; function() {
		$(previewbox).empty().hide();
	};
};


/* **************** Morebits.wikitext **************** */

/**
 * Wikitext manipulation.
 *
 * @namespace Morebits.wikitext
 * @memberof Morebits
 */
Morebits.wikitext &#x3D; {};

/**
 * Get the value of every parameter found in the wikitext of a given template.
 *
 * @memberof Morebits.wikitext
 * @param {string} text - Wikitext containing a template.
 * @param {number} [start&#x3D;0] - Index noting where in the text the template begins.
 * @returns {object} &#x60;{name: templateName, parameters: {key: value}}&#x60;.
 */
Morebits.wikitext.parseTemplate &#x3D; function(text, start) {
	start &#x3D; start || 0;

	var level &#x3D; []; // Track of how deep we are ({{, {{{, or [[)
	var count &#x3D; -1;  // Number of parameters found
	var unnamed &#x3D; 0; // Keep track of what number an unnamed parameter should receive
	var equals &#x3D; -1; // After finding &quot;&#x3D;&quot; before a parameter, the index; otherwise, -1
	var current &#x3D; &#x27;&#x27;;
	var result &#x3D; {
		name: &#x27;&#x27;,
		parameters: {}
	};
	var key, value;

	/**
	 * Function to handle finding parameter values.
	 *
	 * @param {boolean} [final&#x3D;false] - Whether this is the final
	 * parameter and we need to remove the trailing &#x60;}}&#x60;.
	 */
	function findParam(final) {
		// Nothing found yet, this must be the template name
		if (count &#x3D;&#x3D;&#x3D; -1) {
			result.name &#x3D; current.substring(2).trim();
			++count;
		} else {
			// In a parameter
			if (equals !&#x3D;&#x3D; -1) {
				// We found an equals, so save the parameter as key: value
				key &#x3D; current.substring(0, equals).trim();
				value &#x3D; final ? current.substring(equals + 1, current.length - 2).trim() : current.substring(equals + 1).trim();
				result.parameters[key] &#x3D; value;
				equals &#x3D; -1;
			} else {
				// No equals, so it must be unnamed; no trim since whitespace allowed
				var param &#x3D; final ? current.substring(equals + 1, current.length - 2) : current;
				if (param) {
					result.parameters[++unnamed] &#x3D; param;
					++count;
				}
			}
		}
	}

	for (var i &#x3D; start; i &amp;lt; text.length; ++i) {
		var test3 &#x3D; text.substr(i, 3);
		if (test3 &#x3D;&#x3D;&#x3D; &#x27;{{{&#x27; || (test3 &#x3D;&#x3D;&#x3D; &#x27;}}}&#x27; &amp;amp;&amp;amp; level[level.length - 1] &#x3D;&#x3D;&#x3D; 3)) {
			current +&#x3D; test3;
			i +&#x3D; 2;
			if (test3 &#x3D;&#x3D;&#x3D; &#x27;{{{&#x27;) {
				level.push(3);
			} else {
				level.pop();
			}
			continue;
		}
		var test2 &#x3D; text.substr(i, 2);
		// Entering a template (or link)
		if (test2 &#x3D;&#x3D;&#x3D; &#x27;{{&#x27; || test2 &#x3D;&#x3D;&#x3D; &#x27;[[&#x27;) {
			current +&#x3D; test2;
			++i;
			if (test2 &#x3D;&#x3D;&#x3D; &#x27;{{&#x27;) {
				level.push(2);
			} else {
				level.push(&#x27;wl&#x27;);
			}
			continue;
		}
		// Either leaving a link or template/parser function
		if ((test2 &#x3D;&#x3D;&#x3D; &#x27;}}&#x27; &amp;amp;&amp;amp; level[level.length - 1] &#x3D;&#x3D;&#x3D; 2) ||
			(test2 &#x3D;&#x3D;&#x3D; &#x27;]]&#x27; &amp;amp;&amp;amp; level[level.length - 1] &#x3D;&#x3D;&#x3D; &#x27;wl&#x27;)) {
			current +&#x3D; test2;
			++i;
			level.pop();

			// Find the final parameter if this really is the end
			if (test2 &#x3D;&#x3D;&#x3D; &#x27;}}&#x27; &amp;amp;&amp;amp; level.length &#x3D;&#x3D;&#x3D; 0) {
				findParam(true);
				break;
			}
			continue;
		}

		if (text.charAt(i) &#x3D;&#x3D;&#x3D; &#x27;|&#x27; &amp;amp;&amp;amp; level.length &#x3D;&#x3D;&#x3D; 1) {
			// Another pipe found, toplevel, so parameter coming up!
			findParam();
			current &#x3D; &#x27;&#x27;;
		} else if (equals &#x3D;&#x3D;&#x3D; -1 &amp;amp;&amp;amp; text.charAt(i) &#x3D;&#x3D;&#x3D; &#x27;&#x3D;&#x27; &amp;amp;&amp;amp; level.length &#x3D;&#x3D;&#x3D; 1) {
			// Equals found, toplevel
			equals &#x3D; current.length;
			current +&#x3D; text.charAt(i);
		} else {
			// Just advance the position
			current +&#x3D; text.charAt(i);
		}
	}

	return result;
};

/**
 * Adjust and manipulate the wikitext of a page.
 *
 * @class
 * @memberof Morebits.wikitext
 * @param {string} text - Wikitext to be manipulated.
 */
Morebits.wikitext.page &#x3D; function mediawikiPage(text) {
	this.text &#x3D; text;
};

Morebits.wikitext.page.prototype &#x3D; {
	text: &#x27;&#x27;,

	/**
	 * Removes links to &#x60;link_target&#x60; from the page text.
	 *
	 * @param {string} link_target
	 * @returns {Morebits.wikitext.page}
	 */
	removeLink: function(link_target) {
		// Rempve a leading colon, to be handled later
		if (link_target.indexOf(&#x27;:&#x27;) &#x3D;&#x3D;&#x3D; 0) {
			link_target &#x3D; link_target.slice(1);
		}
		var link_re_string &#x3D; &#x27;&#x27;, ns &#x3D; &#x27;&#x27;, title &#x3D; link_target;

		var idx &#x3D; link_target.indexOf(&#x27;:&#x27;);
		if (idx &gt; 0) {
			ns &#x3D; link_target.slice(0, idx);
			title &#x3D; link_target.slice(idx + 1);

			link_re_string &#x3D; Morebits.namespaceRegex(mw.config.get(&#x27;wgNamespaceIds&#x27;)[ns.toLowerCase().replace(/ /g, &#x27;_&#x27;)]) + &#x27;:&#x27;;
		}
		link_re_string +&#x3D; Morebits.pageNameRegex(title);

		// Allow for an optional leading colon, e.g. [[:User:Test]]
		// Files and Categories become links with a leading colon, e.g. [[:File:Test.png]]
		var colon &#x3D; new RegExp(Morebits.namespaceRegex([6, 14])).test(ns) ? &#x27;:&#x27; : &#x27;:?&#x27;;

		var link_simple_re &#x3D; new RegExp(&#x27;\\[\\[&#x27; + colon + &#x27;(&#x27; + link_re_string + &#x27;)\\]\\]&#x27;, &#x27;g&#x27;);
		var link_named_re &#x3D; new RegExp(&#x27;\\[\\[&#x27; + colon + link_re_string + &#x27;\\|(.+?)\\]\\]&#x27;, &#x27;g&#x27;);
		this.text &#x3D; this.text.replace(link_simple_re, &#x27;$1&#x27;).replace(link_named_re, &#x27;$1&#x27;);
		return this;
	},

	/**
	 * Comments out images from page text; if used in a gallery, deletes the whole line.
	 * If used as a template argument (not necessarily with &#x60;File:&#x60; prefix), the template parameter is commented out.
	 *
	 * @param {string} image - Image name without &#x60;File:&#x60; prefix.
	 * @param {string} [reason] - Reason to be included in comment, alongside the commented-out image.
	 * @returns {Morebits.wikitext.page}
	 */
	commentOutImage: function(image, reason) {
		var unbinder &#x3D; new Morebits.unbinder(this.text);
		unbinder.unbind(&#x27;&amp;lt;!--&#x27;, &#x27;--&gt;&#x27;);

		reason &#x3D; reason ? reason + &#x27;: &#x27; : &#x27;&#x27;;
		var image_re_string &#x3D; Morebits.pageNameRegex(image);

		// Check for normal image links, i.e. [[File:Foobar.png|...]]
		// Will eat the whole link
		var links_re &#x3D; new RegExp(&#x27;\\[\\[&#x27; + Morebits.namespaceRegex(6) + &#x27;:\\s*&#x27; + image_re_string + &#x27;\\s*[\\|(?:\\]\\])]&#x27;);
		var allLinks &#x3D; Morebits.string.splitWeightedByKeys(unbinder.content, &#x27;[[&#x27;, &#x27;]]&#x27;);
		for (var i &#x3D; 0; i &amp;lt; allLinks.length; ++i) {
			if (links_re.test(allLinks[i])) {
				var replacement &#x3D; &#x27;&amp;lt;!-- &#x27; + reason + allLinks[i] + &#x27; --&gt;&#x27;;
				unbinder.content &#x3D; unbinder.content.replace(allLinks[i], replacement);
			}
		}
		// unbind the newly created comments
		unbinder.unbind(&#x27;&amp;lt;!--&#x27;, &#x27;--&gt;&#x27;);

		// Check for gallery images, i.e. instances that must start on a new line,
		// eventually preceded with some space, and must include File: prefix
		// Will eat the whole line.
		var gallery_image_re &#x3D; new RegExp(&#x27;(^\\s*&#x27; + Morebits.namespaceRegex(6) + &#x27;:\\s*&#x27; + image_re_string + &#x27;\\s*(?:\\|.*?$|$))&#x27;, &#x27;mg&#x27;);
		unbinder.content &#x3D; unbinder.content.replace(gallery_image_re, &#x27;&amp;lt;!-- &#x27; + reason + &#x27;$1 --&gt;&#x27;);

		// unbind the newly created comments
		unbinder.unbind(&#x27;&amp;lt;!--&#x27;, &#x27;--&gt;&#x27;);

		// Check free image usages, for example as template arguments, might have the File: prefix excluded, but must be preceeded by an |
		// Will only eat the image name and the preceeding bar and an eventual named parameter
		var free_image_re &#x3D; new RegExp(&#x27;(\\|\\s*(?:[\\w\\s]+\\&#x3D;)?\\s*(?:&#x27; + Morebits.namespaceRegex(6) + &#x27;:\\s*)?&#x27; + image_re_string + &#x27;)&#x27;, &#x27;mg&#x27;);
		unbinder.content &#x3D; unbinder.content.replace(free_image_re, &#x27;&amp;lt;!-- &#x27; + reason + &#x27;$1 --&gt;&#x27;);
		// Rebind the content now, we are done!
		this.text &#x3D; unbinder.rebind();
		return this;
	},

	/**
	 * Converts uses of [[File:&#x60;image&#x60;]] to [[File:&#x60;image&#x60;|&#x60;data&#x60;]].
	 *
	 * @param {string} image - Image name without File: prefix.
	 * @param {string} data - The display options.
	 * @returns {Morebits.wikitext.page}
	 */
	addToImageComment: function(image, data) {
		var image_re_string &#x3D; Morebits.pageNameRegex(image);
		var links_re &#x3D; new RegExp(&#x27;\\[\\[&#x27; + Morebits.namespaceRegex(6) + &#x27;:\\s*&#x27; + image_re_string + &#x27;\\s*[\\|(?:\\]\\])]&#x27;);
		var allLinks &#x3D; Morebits.string.splitWeightedByKeys(this.text, &#x27;[[&#x27;, &#x27;]]&#x27;);
		for (var i &#x3D; 0; i &amp;lt; allLinks.length; ++i) {
			if (links_re.test(allLinks[i])) {
				var replacement &#x3D; allLinks[i];
				// just put it at the end?
				replacement &#x3D; replacement.replace(/\]\]$/, &#x27;|&#x27; + data + &#x27;]]&#x27;);
				this.text &#x3D; this.text.replace(allLinks[i], replacement);
			}
		}
		var gallery_re &#x3D; new RegExp(&#x27;^(\\s*&#x27; + image_re_string + &#x27;.*?)\\|?(.*?)$&#x27;, &#x27;mg&#x27;);
		var newtext &#x3D; &#x27;$1|$2 &#x27; + data;
		this.text &#x3D; this.text.replace(gallery_re, newtext);
		return this;
	},

	/**
	 * Remove all transclusions of a template from page text.
	 *
	 * @param {string} template - Page name whose transclusions are to be removed,
	 * include namespace prefix only if not in template namespace.
	 * @returns {Morebits.wikitext.page}
	 */
	removeTemplate: function(template) {
		var template_re_string &#x3D; Morebits.pageNameRegex(template);
		var links_re &#x3D; new RegExp(&#x27;\\{\\{(?:&#x27; + Morebits.namespaceRegex(10) + &#x27;:)?\\s*&#x27; + template_re_string + &#x27;\\s*[\\|(?:\\}\\})]&#x27;);
		var allTemplates &#x3D; Morebits.string.splitWeightedByKeys(this.text, &#x27;{{&#x27;, &#x27;}}&#x27;, [ &#x27;{{{&#x27;, &#x27;}}}&#x27; ]);
		for (var i &#x3D; 0; i &amp;lt; allTemplates.length; ++i) {
			if (links_re.test(allTemplates[i])) {
				this.text &#x3D; this.text.replace(allTemplates[i], &#x27;&#x27;);
			}
		}
		return this;
	},

	/**
	 * Smartly insert a tag atop page text but after specified templates,
	 * such as hatnotes, short description, or deletion and protection templates.
	 * Notably, does *not* insert a newline after the tag.
	 *
	 * @param {string} tag - The tag to be inserted.
	 * @param {string|string[]} regex - Templates after which to insert tag,
	 * given as either as a (regex-valid) string or an array to be joined by pipes.
	 * @param {string} [flags&#x3D;i] - Regex flags to apply.  &#x60;&#x27;&#x27;&#x60; to provide no flags;
	 * other falsey values will default to &#x60;i&#x60;.
	 * @param {string|string[]} [preRegex] - Optional regex string or array to match
	 * before any template matches (i.e. before &#x60;{{&#x60;), such as html comments.
	 * @returns {Morebits.wikitext.page}
	 */
	insertAfterTemplates: function(tag, regex, flags, preRegex) {
		if (typeof tag &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
			throw new Error(&#x27;No tag provided&#x27;);
		}

		// .length is only a property of strings and arrays so we
		// shouldn&#x27;t need to check type
		if (typeof regex &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; || !regex.length) {
			throw new Error(&#x27;No regex provided&#x27;);
		} else if (Array.isArray(regex)) {
			regex &#x3D; regex.join(&#x27;|&#x27;);
		}

		if (typeof flags !&#x3D;&#x3D; &#x27;string&#x27;) {
			flags &#x3D; &#x27;i&#x27;;
		}

		if (!preRegex || !preRegex.length) {
			preRegex &#x3D; &#x27;&#x27;;
		} else if (Array.isArray(preRegex)) {
			preRegex &#x3D; preRegex.join(&#x27;|&#x27;);
		}


		// Regex is extra complicated to allow for templates with
		// parameters and to handle whitespace properly
		this.text &#x3D; this.text.replace(
			new RegExp(
				// leading whitespace
				&#x27;^\\s*&#x27; +
				// capture template(s)
				&#x27;(?:((?:\\s*&#x27; +
				// Pre-template regex, such as leading html comments
				preRegex + &#x27;|&#x27; +
				// begin template format
				&#x27;\\{\\{\\s*(?:&#x27; +
				// Template regex
				regex +
				// end main template name, optionally with a number
				// Probably remove the (?:) though
				&#x27;)\\d*\\s*&#x27; +
				// template parameters
				&#x27;(\\|(?:\\{\\{[^{}]*\\}\\}|[^{}])*)?&#x27; +
				// end template format
				&#x27;\\}\\})+&#x27; +
				// end capture
				&#x27;(?:\\s*\\n)?)&#x27; +
				// trailing whitespace
				&#x27;\\s*)?&#x27;,
				flags), &#x27;$1&#x27; + tag
		);
		return this;
	},

	/**
	 * Get the manipulated wikitext.
	 *
	 * @returns {string}
	 */
	getText: function() {
		return this.text;
	}
};


/* *********** Morebits.userspaceLogger ************ */
/**
 * Handles logging actions to a userspace log.
 * Used in CSD, PROD, and XFD.
 *
 * @memberof Morebits
 * @class
 * @param {string} logPageName - Title of the subpage of the current user&#x27;s log.
 */
Morebits.userspaceLogger &#x3D; function(logPageName) {
	if (!logPageName) {
		throw new Error(&#x27;no log page name specified&#x27;);
	}
	/**
	 * The text to prefix the log with upon creation, defaults to empty.
	 *
	 * @type {string}
	 */
	this.initialText &#x3D; &#x27;&#x27;;
	/**
	 * The header level to use for months, defaults to 3 (&#x60;&#x3D;&#x3D;&#x3D;&#x60;).
	 *
	 * @type {number}
	 */
	this.headerLevel &#x3D; 3;
	this.changeTags &#x3D; &#x27;&#x27;;

	/**
	 * Log the entry.
	 *
	 * @param {string} logText - Doesn&#x27;t include leading &#x60;#&#x60; or &#x60;*&#x60;.
	 * @param {string} summaryText - Edit summary.
	 * @returns {JQuery.Promise}
	 */
	this.log &#x3D; function(logText, summaryText) {
		var def &#x3D; $.Deferred();
		if (!logText) {
			return def.reject();
		}
		var page &#x3D; new Morebits.wiki.page(&#x27;User:&#x27; + mw.config.get(&#x27;wgUserName&#x27;) + &#x27;/&#x27; + logPageName,
			&#x27;Adding entry to userspace log&#x27;); // make this &#x27;... to &#x27; + logPageName ?
		page.load(function(pageobj) {
			// add blurb if log page doesn&#x27;t exist or is blank
			var text &#x3D; pageobj.getPageText() || this.initialText;

			// create monthly header if it doesn&#x27;t exist already
			var date &#x3D; new Morebits.date(pageobj.getLoadTime());
			if (!date.monthHeaderRegex().exec(text)) {
				text +&#x3D; &#x27;\n\n&#x27; + date.monthHeader(this.headerLevel);
			}

			pageobj.setPageText(text + &#x27;\n&#x27; + logText);
			pageobj.setEditSummary(summaryText);
			pageobj.setChangeTags(this.changeTags);
			pageobj.setCreateOption(&#x27;recreate&#x27;);
			pageobj.save(def.resolve, def.reject);
		}.bind(this));
		return def;
	};
};


/* **************** Morebits.status **************** */
/**
 * Create and show status messages of varying urgency.
 * {@link Morebits.status.init|Morebits.status.init()} must be called before
 * any status object is created, otherwise those statuses won&#x27;t be visible.
 *
 * @memberof Morebits
 * @class
 * @param {string} text - Text before the the colon &#x60;:&#x60;.
 * @param {string} stat - Text after the colon &#x60;:&#x60;.
 * @param {string} [type&#x3D;status] - Determine the font color of the status
 * line, allowable values are: &#x60;status&#x60; (blue), &#x60;info&#x60; (green), &#x60;warn&#x60; (red),
 * or &#x60;error&#x60; (bold red).
 */

Morebits.status &#x3D; function Status(text, stat, type) {
	this.textRaw &#x3D; text;
	this.text &#x3D; this.codify(text);
	this.type &#x3D; type || &#x27;status&#x27;;
	this.generate();
	if (stat) {
		this.update(stat, type);
	}
};

/**
 * Specify an area for status message elements to be added to.
 *
 * @memberof Morebits.status
 * @param {HTMLElement} root - Usually a div element.
 * @throws If &#x60;root&#x60; is not an &#x60;HTMLElement&#x60;.
 */
Morebits.status.init &#x3D; function(root) {
	if (!(root instanceof Element)) {
		throw new Error(&#x27;object not an instance of Element&#x27;);
	}
	while (root.hasChildNodes()) {
		root.removeChild(root.firstChild);
	}
	Morebits.status.root &#x3D; root;
	Morebits.status.errorEvent &#x3D; null;
};

Morebits.status.root &#x3D; null;

/**
 * @memberof Morebits.status
 * @param {Function} handler - Function to execute on error.
 * @throws When &#x60;handler&#x60; is not a function.
 */
Morebits.status.onError &#x3D; function(handler) {
	if (typeof handler &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
		Morebits.status.errorEvent &#x3D; handler;
	} else {
		throw &#x27;Morebits.status.onError: handler is not a function&#x27;;
	}
};

Morebits.status.prototype &#x3D; {
	stat: null,
	statRaw: null,
	text: null,
	textRaw: null,
	type: &#x27;status&#x27;,
	target: null,
	node: null,
	linked: false,

	/** Add the status element node to the DOM. */
	link: function() {
		if (!this.linked &amp;amp;&amp;amp; Morebits.status.root) {
			Morebits.status.root.appendChild(this.node);
			this.linked &#x3D; true;
		}
	},

	/** Remove the status element node from the DOM. */
	unlink: function() {
		if (this.linked) {
			Morebits.status.root.removeChild(this.node);
			this.linked &#x3D; false;
		}
	},

	/**
	 * Create a document fragment with the status text, parsing as HTML.
	 * Runs upon construction for text (part before colon) and upon
	 * render/update for status (part after colon).
	 *
	 * @param {(string|Element|Array)} obj
	 * @returns {DocumentFragment}
	 */
	codify: function(obj) {
		if (!Array.isArray(obj)) {
			obj &#x3D; [ obj ];
		}
		var result;
		result &#x3D; document.createDocumentFragment();
		for (var i &#x3D; 0; i &amp;lt; obj.length; ++i) {
			if (obj[i] instanceof Element) {
				result.appendChild(obj[i]);
			} else {
				$.parseHTML(obj[i]).forEach(function(elem) {
					result.appendChild(elem);
				});
			}
		}
		return result;

	},

	/**
	 * Update the status.
	 *
	 * @param {string} status - Part of status message after colon.
	 * @param {string} type - &#x27;status&#x27; (blue), &#x27;info&#x27; (green), &#x27;warn&#x27;
	 * (red), or &#x27;error&#x27; (bold red).
	 */
	update: function(status, type) {
		this.statRaw &#x3D; status;
		this.stat &#x3D; this.codify(status);
		if (type) {
			this.type &#x3D; type;
			if (type &#x3D;&#x3D;&#x3D; &#x27;error&#x27;) {
				// hack to force the page not to reload when an error is output - see also Morebits.status() above
				Morebits.wiki.numberOfActionsLeft &#x3D; 1000;

				// call error callback
				if (Morebits.status.errorEvent) {
					Morebits.status.errorEvent();
				}

				// also log error messages in the browser console
				console.error(this.textRaw + &#x27;: &#x27; + this.statRaw); // eslint-disable-line no-console
			}
		}
		this.render();
	},

	/** Produce the html for first part of the status message. */
	generate: function() {
		this.node &#x3D; document.createElement(&#x27;div&#x27;);
		this.node.appendChild(document.createElement(&#x27;span&#x27;)).appendChild(this.text);
		this.node.appendChild(document.createElement(&#x27;span&#x27;)).appendChild(document.createTextNode(&#x27;: &#x27;));
		this.target &#x3D; this.node.appendChild(document.createElement(&#x27;span&#x27;));
		this.target.appendChild(document.createTextNode(&#x27;&#x27;)); // dummy node
	},

	/** Complete the html, for the second part of the status message. */
	render: function() {
		this.node.className &#x3D; &#x27;morebits_status_&#x27; + this.type;
		while (this.target.hasChildNodes()) {
			this.target.removeChild(this.target.firstChild);
		}
		this.target.appendChild(this.stat);
		this.link();
	},
	status: function(status) {
		this.update(status, &#x27;status&#x27;);
	},
	info: function(status) {
		this.update(status, &#x27;info&#x27;);
	},
	warn: function(status) {
		this.update(status, &#x27;warn&#x27;);
	},
	error: function(status) {
		this.update(status, &#x27;error&#x27;);
	}
};
/**
 * @memberof Morebits.status
 * @param {string} text - Before colon
 * @param {string} status - After colon
 * @returns {Morebits.status} - &#x60;status&#x60;-type (blue)
 */
Morebits.status.status &#x3D; function(text, status) {
	return new Morebits.status(text, status);
};
/**
 * @memberof Morebits.status
 * @param {string} text - Before colon
 * @param {string} status - After colon
 * @returns {Morebits.status} - &#x60;info&#x60;-type (green)
 */
Morebits.status.info &#x3D; function(text, status) {
	return new Morebits.status(text, status, &#x27;info&#x27;);
};
/**
 * @memberof Morebits.status
 * @param {string} text - Before colon
 * @param {string} status - After colon
 * @returns {Morebits.status} - &#x60;warn&#x60;-type (red)
 */
Morebits.status.warn &#x3D; function(text, status) {
	return new Morebits.status(text, status, &#x27;warn&#x27;);
};
/**
 * @memberof Morebits.status
 * @param {string} text - Before colon
 * @param {string} status - After colon
 * @returns {Morebits.status} - &#x60;error&#x60;-type (bold red)
 */
Morebits.status.error &#x3D; function(text, status) {
	return new Morebits.status(text, status, &#x27;error&#x27;);
};

/**
 * For the action complete message at the end, create a status line without
 * a colon separator.
 *
 * @memberof Morebits.status
 * @param {string} text
 */
Morebits.status.actionCompleted &#x3D; function(text) {
	var node &#x3D; document.createElement(&#x27;div&#x27;);
	node.appendChild(document.createElement(&#x27;b&#x27;)).appendChild(document.createTextNode(text));
	node.className &#x3D; &#x27;morebits_status_info&#x27;;
	if (Morebits.status.root) {
		Morebits.status.root.appendChild(node);
	}
};

/**
 * Display the user&#x27;s rationale, comments, etc. Back to them after a failure,
 * so that they may re-use it.
 *
 * @memberof Morebits.status
 * @param {string} comments
 * @param {string} message
 */
Morebits.status.printUserText &#x3D; function(comments, message) {
	var p &#x3D; document.createElement(&#x27;p&#x27;);
	p.innerHTML &#x3D; message;
	var div &#x3D; document.createElement(&#x27;div&#x27;);
	div.className &#x3D; &#x27;toccolours&#x27;;
	div.style.marginTop &#x3D; &#x27;0&#x27;;
	div.style.whiteSpace &#x3D; &#x27;pre-wrap&#x27;;
	div.textContent &#x3D; comments;
	p.appendChild(div);
	Morebits.status.root.appendChild(p);
};



/**
 * Simple helper function to create a simple node.
 *
 * @param {string} type - Type of HTML element.
 * @param {string} content - Text content.
 * @param {string} [color] - Font color.
 * @returns {HTMLElement}
 */
Morebits.htmlNode &#x3D; function (type, content, color) {
	var node &#x3D; document.createElement(type);
	if (color) {
		node.style.color &#x3D; color;
	}
	node.appendChild(document.createTextNode(content));
	return node;
};



/**
 * Add shift-click support for checkboxes. The wikibits version
 * (&#x60;window.addCheckboxClickHandlers&#x60;) has some restrictions, and doesn&#x27;t work
 * with checkboxes inside a sortable table, so let&#x27;s build our own.
 *
 * @param jQuerySelector
 * @param jQueryContext
 */
Morebits.checkboxShiftClickSupport &#x3D; function (jQuerySelector, jQueryContext) {
	var lastCheckbox &#x3D; null;

	function clickHandler(event) {
		var thisCb &#x3D; this;
		if (event.shiftKey &amp;amp;&amp;amp; lastCheckbox !&#x3D;&#x3D; null) {
			var cbs &#x3D; $(jQuerySelector, jQueryContext); // can&#x27;t cache them, obviously, if we want to support resorting
			var index &#x3D; -1, lastIndex &#x3D; -1, i;
			for (i &#x3D; 0; i &amp;lt; cbs.length; i++) {
				if (cbs[i] &#x3D;&#x3D;&#x3D; thisCb) {
					index &#x3D; i;
					if (lastIndex &gt; -1) {
						break;
					}
				}
				if (cbs[i] &#x3D;&#x3D;&#x3D; lastCheckbox) {
					lastIndex &#x3D; i;
					if (index &gt; -1) {
						break;
					}
				}
			}

			if (index &gt; -1 &amp;amp;&amp;amp; lastIndex &gt; -1) {
				// inspired by wikibits
				var endState &#x3D; thisCb.checked;
				var start, finish;
				if (index &amp;lt; lastIndex) {
					start &#x3D; index + 1;
					finish &#x3D; lastIndex;
				} else {
					start &#x3D; lastIndex;
					finish &#x3D; index - 1;
				}

				for (i &#x3D; start; i &amp;lt;&#x3D; finish; i++) {
					if (cbs[i].checked !&#x3D;&#x3D; endState) {
						cbs[i].click();
					}
				}
			}
		}
		lastCheckbox &#x3D; thisCb;
		return true;
	}

	$(jQuerySelector, jQueryContext).click(clickHandler);
};



/* **************** Morebits.batchOperation **************** */
/**
 * Iterates over a group of pages (or arbitrary objects) and executes a worker function
 * for each.
 *
 * &#x60;setPageList(pageList)&#x60;: Sets the list of pages to work on. It should be an
 * array of page names strings.
 *
 * &#x60;setOption(optionName, optionValue)&#x60;: Sets a known option:
 * - &#x60;chunkSize&#x60; (integer): The size of chunks to break the array into (default
 * 50). Setting this to a small value (&amp;lt;5) can cause problems.
 * - &#x60;preserveIndividualStatusLines&#x60; (boolean): Keep each page&#x27;s status element
 * visible when worker is complete? See note below.
 *
 * &#x60;run(worker, postFinish)&#x60;: Runs the callback &#x60;worker&#x60; for each page in the
 * list.  The callback must call &#x60;workerSuccess&#x60; when succeeding, or
 * &#x60;workerFailure&#x60; when failing.  If using {@link Morebits.wiki.api} or
 * {@link Morebits.wiki.page}, this is easily done by passing these two
 * functions as parameters to the methods on those objects: for instance,
 * &#x60;page.save(batchOp.workerSuccess, batchOp.workerFailure)&#x60;.  Make sure the
 * methods are called directly if special success/failure cases arise.  If you
 * omit to call these methods, the batch operation will stall after the first
 * chunk!  Also ensure that either workerSuccess or workerFailure is called no
 * more than once.  The second callback &#x60;postFinish&#x60; is executed when the
 * entire batch has been processed.
 *
 * If using &#x60;preserveIndividualStatusLines&#x60;, you should try to ensure that the
 * &#x60;workerSuccess&#x60; callback has access to the page title.  This is no problem for
 * {@link Morebits.wiki.page} objects.  But when using the API, please set the
 * |pageName| property on the {@link Morebits.wiki.api} object.
 *
 * There are sample batchOperation implementations using Morebits.wiki.page in
 * twinklebatchdelete.js, twinklebatchundelete.js, and twinklebatchprotect.js.
 *
 * @memberof Morebits
 * @class
 * @param {string} [currentAction]
 */
Morebits.batchOperation &#x3D; function(currentAction) {
	var ctx &#x3D; {
		// backing fields for public properties
		pageList: null,
		options: {
			chunkSize: 50,
			preserveIndividualStatusLines: false
		},

		// internal counters, etc.
		statusElement: new Morebits.status(currentAction || &#x27;Performing batch operation&#x27;),
		worker: null, // function that executes for each item in pageList
		postFinish: null, // function that executes when the whole batch has been processed
		countStarted: 0,
		countFinished: 0,
		countFinishedSuccess: 0,
		currentChunkIndex: -1,
		pageChunks: [],
		running: false
	};

	// shouldn&#x27;t be needed by external users, but provided anyway for maximum flexibility
	this.getStatusElement &#x3D; function() {
		return ctx.statusElement;
	};

	/**
	 * Sets the list of pages to work on.
	 *
	 * @param {Array} pageList - Array of objects over which you wish to execute the worker function
	 * This is usually the list of page names (strings).
	 */
	this.setPageList &#x3D; function(pageList) {
		ctx.pageList &#x3D; pageList;
	};

	/**
	 * Sets a known option.
	 *
	 * @param {string} optionName - Name of the option:
	 * - chunkSize (integer): The size of chunks to break the array into
	 * (default 50). Setting this to a small value (&amp;lt;5) can cause problems.
	 * - preserveIndividualStatusLines (boolean): Keep each page&#x27;s status
	 * element visible when worker is complete?
	 * @param {number|boolean} optionValue - Value to which the option is
	 * to be set. Should be an integer for chunkSize and a boolean for
	 * preserveIndividualStatusLines.
	 */
	this.setOption &#x3D; function(optionName, optionValue) {
		ctx.options[optionName] &#x3D; optionValue;
	};

	/**
	 * Runs the first callback for each page in the list.
	 * The callback must call workerSuccess when succeeding, or workerFailure when failing.
	 * Runs the optional second callback when the whole batch has been processed.
	 *
	 * @param {Function} worker
	 * @param {Function} [postFinish]
	 */
	this.run &#x3D; function(worker, postFinish) {
		if (ctx.running) {
			ctx.statusElement.error(&#x27;Batch operation is already running&#x27;);
			return;
		}
		ctx.running &#x3D; true;

		ctx.worker &#x3D; worker;
		ctx.postFinish &#x3D; postFinish;
		ctx.countStarted &#x3D; 0;
		ctx.countFinished &#x3D; 0;
		ctx.countFinishedSuccess &#x3D; 0;
		ctx.currentChunkIndex &#x3D; -1;
		ctx.pageChunks &#x3D; [];

		var total &#x3D; ctx.pageList.length;
		if (!total) {
			ctx.statusElement.info(&#x27;no pages specified&#x27;);
			ctx.running &#x3D; false;
			if (ctx.postFinish) {
				ctx.postFinish();
			}
			return;
		}

		// chunk page list into more manageable units
		ctx.pageChunks &#x3D; Morebits.array.chunk(ctx.pageList, ctx.options.chunkSize);

		// start the process
		Morebits.wiki.addCheckpoint();
		ctx.statusElement.status(&#x27;0%&#x27;);
		fnStartNewChunk();
	};

	/**
	 * To be called by worker before it terminates succesfully.
	 *
	 * @param {(Morebits.wiki.page|Morebits.wiki.api|string)} arg -
	 * This should be the &#x60;Morebits.wiki.page&#x60; or &#x60;Morebits.wiki.api&#x60; object used by worker
	 * (for the adjustment of status lines emitted by them).
	 * If no Morebits.wiki.* object is used (e.g. you&#x27;re using &#x60;mw.Api()&#x60; or something else), and
	 * &#x60;preserveIndividualStatusLines&#x60; option is on, give the page name (string) as argument.
	 */
	this.workerSuccess &#x3D; function(arg) {

		var createPageLink &#x3D; function(pageName) {
			var link &#x3D; document.createElement(&#x27;a&#x27;);
			link.setAttribute(&#x27;href&#x27;, mw.util.getUrl(pageName));
			link.appendChild(document.createTextNode(pageName));
			return link;
		};

		if (arg instanceof Morebits.wiki.api || arg instanceof Morebits.wiki.page) {
			// update or remove status line
			var statelem &#x3D; arg.getStatusElement();
			if (ctx.options.preserveIndividualStatusLines) {
				if (arg.getPageName || arg.pageName || (arg.query &amp;amp;&amp;amp; arg.query.title)) {
					// we know the page title - display a relevant message
					var pageName &#x3D; arg.getPageName ? arg.getPageName() : arg.pageName || arg.query.title;
					statelem.info([&#x27;completed (&#x27;, createPageLink(pageName), &#x27;)&#x27;]);
				} else {
					// we don&#x27;t know the page title - just display a generic message
					statelem.info(&#x27;done&#x27;);
				}
			} else {
				// remove the status line automatically produced by Morebits.wiki.*
				statelem.unlink();
			}

		} else if (typeof arg &#x3D;&#x3D;&#x3D; &#x27;string&#x27; &amp;amp;&amp;amp; ctx.options.preserveIndividualStatusLines) {
			new Morebits.status(arg, [&#x27;done (&#x27;, createPageLink(arg), &#x27;)&#x27;]);
		}

		ctx.countFinishedSuccess++;
		fnDoneOne();
	};

	this.workerFailure &#x3D; function() {
		fnDoneOne();
	};

	// private functions

	var thisProxy &#x3D; this;

	var fnStartNewChunk &#x3D; function() {
		var chunk &#x3D; ctx.pageChunks[++ctx.currentChunkIndex];
		if (!chunk) {
			return;  // done! yay
		}

		// start workers for the current chunk
		ctx.countStarted +&#x3D; chunk.length;
		chunk.forEach(function(page) {
			ctx.worker(page, thisProxy);
		});
	};

	var fnDoneOne &#x3D; function() {
		ctx.countFinished++;

		// update overall status line
		var total &#x3D; ctx.pageList.length;
		if (ctx.countFinished &amp;lt; total) {
			ctx.statusElement.status(parseInt(100 * ctx.countFinished / total, 10) + &#x27;%&#x27;);

			// start a new chunk if we&#x27;re close enough to the end of the previous chunk, and
			// we haven&#x27;t already started the next one
			if (ctx.countFinished &gt;&#x3D; (ctx.countStarted - Math.max(ctx.options.chunkSize / 10, 2)) &amp;amp;&amp;amp;
				Math.floor(ctx.countFinished / ctx.options.chunkSize) &gt; ctx.currentChunkIndex) {
				fnStartNewChunk();
			}
		} else if (ctx.countFinished &#x3D;&#x3D;&#x3D; total) {
			var statusString &#x3D; &#x27;Done (&#x27; + ctx.countFinishedSuccess +
				&#x27;/&#x27; + ctx.countFinished + &#x27; actions completed successfully)&#x27;;
			if (ctx.countFinishedSuccess &amp;lt; ctx.countFinished) {
				ctx.statusElement.warn(statusString);
			} else {
				ctx.statusElement.info(statusString);
			}
			if (ctx.postFinish) {
				ctx.postFinish();
			}
			Morebits.wiki.removeCheckpoint();
			ctx.running &#x3D; false;
		} else {
			// ctx.countFinished &gt; total
			// just for giggles! (well, serious debugging, actually)
			ctx.statusElement.warn(&#x27;Done (overshot by &#x27; + (ctx.countFinished - total) + &#x27;)&#x27;);
			Morebits.wiki.removeCheckpoint();
			ctx.running &#x3D; false;
		}
	};
};

/**
 * Given a set of asynchronous functions to run along with their dependencies,
 * figure out an efficient sequence of running them so that multiple functions
 * that don&#x27;t depend on each other are triggered simultaneously. Where
 * dependencies exist, it ensures that the dependency functions finish running
 * before the dependent function runs. The values resolved by the dependencies
 * are made available to the dependant as arguments.
 *
 * @memberof Morebits
 * @class
 */
Morebits.taskManager &#x3D; function() {
	this.taskDependencyMap &#x3D; new Map();
	this.deferreds &#x3D; new Map();
	this.allDeferreds &#x3D; []; // Hack: IE doesn&#x27;t support Map.prototype.values

	/**
	 * Register a task along with its dependencies (tasks which should have finished
	 * execution before we can begin this one). Each task is a function that must return
	 * a promise. The function will get the values resolved by the dependency functions
	 * as arguments.
	 *
	 * @param {Function} func - A task.
	 * @param {Function[]} deps - Its dependencies.
	 */
	this.add &#x3D; function(func, deps) {
		this.taskDependencyMap.set(func, deps);
		var deferred &#x3D; $.Deferred();
		this.deferreds.set(func, deferred);
		this.allDeferreds.push(deferred);
	};

	/**
	 * Run all the tasks. Multiple tasks may be run at once.
	 *
	 * @returns {promise} - A jQuery promise object that is resolved or rejected with the api object.
	 */
	this.execute &#x3D; function() {
		var self &#x3D; this; // proxy for &#x60;this&#x60; for use inside functions where &#x60;this&#x60; is something else
		this.taskDependencyMap.forEach(function(deps, task) {
			var dependencyPromisesArray &#x3D; deps.map(function(dep) {
				return self.deferreds.get(dep);
			});
			$.when.apply(null, dependencyPromisesArray).then(function() {
				task.apply(null, arguments).then(function() {
					self.deferreds.get(task).resolve.apply(null, arguments);
				});
			});
		});
		return $.when.apply(null, this.allDeferreds); // resolved when everything is done!
	};

};

/**
 * A simple draggable window, now a wrapper for jQuery UI&#x27;s dialog feature.
 *
 * @memberof Morebits
 * @class
 * @requires jquery.ui.dialog
 * @param {number} width
 * @param {number} height - The maximum allowable height for the content area.
 */
Morebits.simpleWindow &#x3D; function SimpleWindow(width, height) {
	var content &#x3D; document.createElement(&#x27;div&#x27;);
	this.content &#x3D; content;
	content.className &#x3D; &#x27;morebits-dialog-content&#x27;;
	content.id &#x3D; &#x27;morebits-dialog-content-&#x27; + Math.round(Math.random() * 1e15);

	this.height &#x3D; height;

	$(this.content).dialog({
		autoOpen: false,
		buttons: { &#x27;Placeholder button&#x27;: function() {} },
		dialogClass: &#x27;morebits-dialog&#x27;,
		width: Math.min(parseInt(window.innerWidth, 10), parseInt(width ? width : 800, 10)),
		// give jQuery the given height value (which represents the anticipated height of the dialog) here, so
		// it can position the dialog appropriately
		// the 20 pixels represents adjustment for the extra height of the jQuery dialog &quot;chrome&quot;, compared
		// to that of the old SimpleWindow
		height: height + 20,
		close: function(event) {
			// dialogs and their content can be destroyed once closed
			$(event.target).dialog(&#x27;destroy&#x27;).remove();
		},
		resizeStart: function() {
			this.scrollbox &#x3D; $(this).find(&#x27;.morebits-scrollbox&#x27;)[0];
			if (this.scrollbox) {
				this.scrollbox.style.maxHeight &#x3D; &#x27;none&#x27;;
			}
		},
		resizeEnd: function() {
			this.scrollbox &#x3D; null;
		},
		resize: function() {
			this.style.maxHeight &#x3D; &#x27;&#x27;;
			if (this.scrollbox) {
				this.scrollbox.style.width &#x3D; &#x27;&#x27;;
			}
		}
	});

	var $widget &#x3D; $(this.content).dialog(&#x27;widget&#x27;);

	// delete the placeholder button (it&#x27;s only there so the buttonpane gets created)
	$widget.find(&#x27;button&#x27;).each(function(key, value) {
		value.parentNode.removeChild(value);
	});

	// add container for the buttons we add, and the footer links (if any)
	var buttonspan &#x3D; document.createElement(&#x27;span&#x27;);
	buttonspan.className &#x3D; &#x27;morebits-dialog-buttons&#x27;;
	var linksspan &#x3D; document.createElement(&#x27;span&#x27;);
	linksspan.className &#x3D; &#x27;morebits-dialog-footerlinks&#x27;;
	$widget.find(&#x27;.ui-dialog-buttonpane&#x27;).append(buttonspan, linksspan);

	// resize the scrollbox with the dialog, if one is present
	$widget.resizable(&#x27;option&#x27;, &#x27;alsoResize&#x27;, &#x27;#&#x27; + this.content.id + &#x27; .morebits-scrollbox, #&#x27; + this.content.id);
};

Morebits.simpleWindow.prototype &#x3D; {
	buttons: [],
	height: 600,
	hasFooterLinks: false,
	scriptName: null,

	/**
	 * Focuses the dialog. This might work, or on the contrary, it might not.
	 *
	 * @returns {Morebits.simpleWindow}
	 */
	focus: function() {
		$(this.content).dialog(&#x27;moveToTop&#x27;);
		return this;
	},

	/**
	 * Closes the dialog. If this is set as an event handler, it will stop the event
	 * from doing anything more.
	 *
	 * @param {event} [event]
	 * @returns {Morebits.simpleWindow}
	 */
	close: function(event) {
		if (event) {
			event.preventDefault();
		}
		$(this.content).dialog(&#x27;close&#x27;);
		return this;
	},

	/**
	 * Shows the dialog. Calling display() on a dialog that has previously been closed
	 * might work, but it is not guaranteed.
	 *
	 * @returns {Morebits.simpleWindow}
	 */
	display: function() {
		if (this.scriptName) {
			var $widget &#x3D; $(this.content).dialog(&#x27;widget&#x27;);
			$widget.find(&#x27;.morebits-dialog-scriptname&#x27;).remove();
			var scriptnamespan &#x3D; document.createElement(&#x27;span&#x27;);
			scriptnamespan.className &#x3D; &#x27;morebits-dialog-scriptname&#x27;;
			scriptnamespan.textContent &#x3D; this.scriptName + &#x27; \u00B7 &#x27;;  // U+00B7 MIDDLE DOT &#x3D; &amp;amp;middot;
			$widget.find(&#x27;.ui-dialog-title&#x27;).prepend(scriptnamespan);
		}

		var dialog &#x3D; $(this.content).dialog(&#x27;open&#x27;);
		if (window.setupTooltips &amp;amp;&amp;amp; window.pg &amp;amp;&amp;amp; window.pg.re &amp;amp;&amp;amp; window.pg.re.diff) {  // tie in with NAVPOP
			dialog.parent()[0].ranSetupTooltipsAlready &#x3D; false;
			window.setupTooltips(dialog.parent()[0]);
		}
		this.setHeight(this.height);  // init height algorithm
		return this;
	},

	/**
	 * Sets the dialog title.
	 *
	 * @param {string} title
	 * @returns {Morebits.simpleWindow}
	 */
	setTitle: function(title) {
		$(this.content).dialog(&#x27;option&#x27;, &#x27;title&#x27;, title);
		return this;
	},

	/**
	 * Sets the script name, appearing as a prefix to the title to help users determine which
	 * user script is producing which dialog. For instance, Twinkle modules set this to &quot;Twinkle&quot;.
	 *
	 * @param {string} name
	 * @returns {Morebits.simpleWindow}
	 */
	setScriptName: function(name) {
		this.scriptName &#x3D; name;
		return this;
	},

	/**
	 * Sets the dialog width.
	 *
	 * @param {number} width
	 * @returns {Morebits.simpleWindow}
	 */
	setWidth: function(width) {
		$(this.content).dialog(&#x27;option&#x27;, &#x27;width&#x27;, width);
		return this;
	},

	/**
	 * Sets the dialog&#x27;s maximum height. The dialog will auto-size to fit its contents,
	 * but the content area will grow no larger than the height given here.
	 *
	 * @param {number} height
	 * @returns {Morebits.simpleWindow}
	 */
	setHeight: function(height) {
		this.height &#x3D; height;

		// from display time onwards, let the browser determine the optimum height,
		// and instead limit the height at the given value
		// note that the given height will exclude the approx. 20px that the jQuery UI
		// chrome has in height in addition to the height of an equivalent &quot;classic&quot;
		// Morebits.simpleWindow
		if (parseInt(getComputedStyle($(this.content).dialog(&#x27;widget&#x27;)[0], null).height, 10) &gt; window.innerHeight) {
			$(this.content).dialog(&#x27;option&#x27;, &#x27;height&#x27;, window.innerHeight - 2).dialog(&#x27;option&#x27;, &#x27;position&#x27;, &#x27;top&#x27;);
		} else {
			$(this.content).dialog(&#x27;option&#x27;, &#x27;height&#x27;, &#x27;auto&#x27;);
		}
		$(this.content).dialog(&#x27;widget&#x27;).find(&#x27;.morebits-dialog-content&#x27;)[0].style.maxHeight &#x3D; parseInt(this.height - 30, 10) + &#x27;px&#x27;;
		return this;
	},

	/**
	 * Sets the content of the dialog to the given element node, usually from rendering
	 * a {@link Morebits.quickForm}.
	 * Re-enumerates the footer buttons, but leaves the footer links as they are.
	 * Be sure to call this at least once before the dialog is displayed...
	 *
	 * @param {HTMLElement} content
	 * @returns {Morebits.simpleWindow}
	 */
	setContent: function(content) {
		this.purgeContent();
		this.addContent(content);
		return this;
	},

	/**
	 * Adds the given element node to the dialog content.
	 *
	 * @param {HTMLElement} content
	 * @returns {Morebits.simpleWindow}
	 */
	addContent: function(content) {
		this.content.appendChild(content);

		// look for submit buttons in the content, hide them, and add a proxy button to the button pane
		var thisproxy &#x3D; this;
		$(this.content).find(&#x27;input[type&#x3D;&quot;submit&quot;], button[type&#x3D;&quot;submit&quot;]&#x27;).each(function(key, value) {
			value.style.display &#x3D; &#x27;none&#x27;;
			var button &#x3D; document.createElement(&#x27;button&#x27;);
			button.textContent &#x3D; value.hasAttribute(&#x27;value&#x27;) ? value.getAttribute(&#x27;value&#x27;) : value.textContent ? value.textContent : &#x27;Submit Query&#x27;;
			button.className &#x3D; value.className || &#x27;submitButtonProxy&#x27;;
			// here is an instance of cheap coding, probably a memory-usage hit in using a closure here
			button.addEventListener(&#x27;click&#x27;, function() {
				value.click();
			}, false);
			thisproxy.buttons.push(button);
		});
		// remove all buttons from the button pane and re-add them
		if (this.buttons.length &gt; 0) {
			$(this.content).dialog(&#x27;widget&#x27;).find(&#x27;.morebits-dialog-buttons&#x27;).empty().append(this.buttons)[0].removeAttribute(&#x27;data-empty&#x27;);
		} else {
			$(this.content).dialog(&#x27;widget&#x27;).find(&#x27;.morebits-dialog-buttons&#x27;)[0].setAttribute(&#x27;data-empty&#x27;, &#x27;data-empty&#x27;);  // used by CSS
		}
		return this;
	},

	/**
	 * Removes all contents from the dialog, barring any footer links.
	 *
	 * @returns {Morebits.simpleWindow}
	 */
	purgeContent: function() {
		this.buttons &#x3D; [];
		// delete all buttons in the buttonpane
		$(this.content).dialog(&#x27;widget&#x27;).find(&#x27;.morebits-dialog-buttons&#x27;).empty();

		while (this.content.hasChildNodes()) {
			this.content.removeChild(this.content.firstChild);
		}
		return this;
	},

	/**
	 * Adds a link in the bottom-right corner of the dialog.
	 * This can be used to provide help or policy links.
	 * For example, Twinkle&#x27;s CSD module adds a link to the CSD policy page,
	 * as well as a link to Twinkle&#x27;s documentation.
	 *
	 * @param {string} text - Display text.
	 * @param {string} wikiPage - Link target.
	 * @param {boolean} [prep&#x3D;false] - Set true to prepend rather than append.
	 * @returns {Morebits.simpleWindow}
	 */
	addFooterLink: function(text, wikiPage, prep) {
		var $footerlinks &#x3D; $(this.content).dialog(&#x27;widget&#x27;).find(&#x27;.morebits-dialog-footerlinks&#x27;);
		if (this.hasFooterLinks) {
			var bullet &#x3D; document.createElement(&#x27;span&#x27;);
			bullet.textContent &#x3D; &#x27; \u2022 &#x27;;  // U+2022 BULLET
			if (prep) {
				$footerlinks.prepend(bullet);
			} else {
				$footerlinks.append(bullet);
			}
		}
		var link &#x3D; document.createElement(&#x27;a&#x27;);
		link.setAttribute(&#x27;href&#x27;, mw.util.getUrl(wikiPage));
		link.setAttribute(&#x27;title&#x27;, wikiPage);
		link.setAttribute(&#x27;target&#x27;, &#x27;_blank&#x27;);
		link.textContent &#x3D; text;
		if (prep) {
			$footerlinks.prepend(link);
		} else {
			$footerlinks.append(link);
		}
		this.hasFooterLinks &#x3D; true;
		return this;
	},

	/**
	 * Sets whether the window should be modal or not. Modal dialogs create
	 * an overlay below the dialog but above other page elements. This
	 * must be used (if necessary) before calling display().
	 *
	 * @param {boolean} [modal&#x3D;false] - If set to true, other items on the
	 * page will be disabled, i.e., cannot be interacted with.
	 * @returns {Morebits.simpleWindow}
	 */
	setModality: function(modal) {
		$(this.content).dialog(&#x27;option&#x27;, &#x27;modal&#x27;, modal);
		return this;
	}
};

/**
 * Enables or disables all footer buttons on all {@link Morebits.simpleWindow}s in the current page.
 * This should be called with &#x60;false&#x60; when the button(s) become irrelevant (e.g. just before
 * {@link Morebits.status.init} is called).
 * This is not an instance method so that consumers don&#x27;t have to keep a reference to the
 * original &#x60;Morebits.simpleWindow&#x60; object sitting around somewhere. Anyway, most of the time
 * there will only be one &#x60;Morebits.simpleWindow&#x60; open, so this shouldn&#x27;t matter.
 *
 * @memberof Morebits.simpleWindow
 * @param {boolean} enabled
 */
Morebits.simpleWindow.setButtonsEnabled &#x3D; function(enabled) {
	$(&#x27;.morebits-dialog-buttons button&#x27;).prop(&#x27;disabled&#x27;, !enabled);
};


}(window, document, jQuery)); // End wrap with anonymous function


/**
 * If this script is being executed outside a ResourceLoader context, we add some
 * global assignments for legacy scripts, hopefully these can be removed down the line.
 *
 * IMPORTANT NOTE:
 * PLEASE DO NOT USE THESE ALIASES IN NEW CODE!
 * Thanks.
 */

if (typeof arguments &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {  // typeof is here for a reason...
	/* global Morebits */
	window.SimpleWindow &#x3D; Morebits.simpleWindow;
	window.QuickForm &#x3D; Morebits.quickForm;
	window.Wikipedia &#x3D; Morebits.wiki;
	window.Status &#x3D; Morebits.status;
}

// &amp;lt;/nowiki&gt;
</code></pre>
            </article>
                                        </div>
                                </div>
                                <nav id="jsdoc-toc-nav" role="navigation"></nav>
                        </div>
                </div>
                    <footer id="jsdoc-footer" class="jsdoc-footer">
                            <div id="jsdoc-footer-container">
                                    <p>
                                      Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.6.6 on January 26, 2021.
                                    </p>
                            </div>
                    </footer>
                <script src="scripts/jquery.min.js"></script>
                <script src="scripts/tree.jquery.js"></script>
                <script src="scripts/prettify.js"></script>
                <script src="scripts/jsdoc-toc.js"></script>
                <script src="scripts/linenumber.js"></script>
                <script src="scripts/scrollanchor.js"></script>
        </body>
</html>
